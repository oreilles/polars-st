{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installing-polars-st","title":"Installing polars-st","text":"<pre><code>pip install polars-st\n</code></pre>"},{"location":"#basics","title":"Basics","text":"<p><code>polars-st</code> provides geometry operations under the namespace <code>st</code> on Polars <code>Expr</code>, <code>Series</code>, <code>DataFrame</code> and  <code>LazyFrame</code>. Functions used to read files or parse geometries are available at the module root. Here's a basic example:</p> <pre><code>&gt;&gt;&gt; import polars_st as st\n&gt;&gt;&gt; gdf = st.GeoDataFrame({\n...     \"geometry\": [\n...         \"POLYGON ((0 0, 0 1, 1 1, 1 0, 0 0))\",\n...         \"POLYGON ((0 0, 0 1, 1 1, 0 0))\",\n...     ]\n... })\n&gt;&gt;&gt; area = gdf.select(st.geom(\"geometry\").st.area())\n</code></pre> <p>Behind the scenes, the GeoDataFrame constructor will parse each geometry from the user input into its EWKB internal representation. WKT is used as an example here but many different type of input are supported. If the spatial data you have is already in a Series, you can also call the parser functions directly;</p> <pre><code>&gt;&gt;&gt; s = pl.Series([\"POLYGON ((0 0, 0 1, 1 1, 1 0, 0 0))\", \"POLYGON ((0 0, 0 1, 1 1, 0 0))\"])\n&gt;&gt;&gt; gdf = pl.select(geometry=st.from_wkt(\"geometry\"))\n</code></pre> <p>In polars-st, the <code>GeoDataFrame</code> constructor is just a utility returning a regular polars <code>DataFrame</code>.  As a result, the <code>gdf</code> object will be exactly identical in the two examples above. </p> <p>In order to support autocompletions and type checking for the <code>st</code> namespace, <code>polars-st</code> provides a utility function <code>st.geom</code>, with the same signature as <code>pl.col</code>, but which returns <code>GeoExpr</code> instead of <code>Expr</code>. <code>GeoExpr</code> is (kinda) just a type alias to polars <code>Expr</code> with type annotations added for the <code>st</code> namespace. It is therefore recommended that you use <code>st.geom</code> instead of <code>pl.col</code> to query geometry columns - even though both will yield identical results.</p> <p>In addition to type checking, <code>st.geom</code> also has a trick up its sleeve: assuming the geometry column matches the default (\"geometry\"), you can even omit typing the column name entirely:</p> <pre><code>&gt;&gt;&gt; area = gdf.select(st.geom().st.area())\n</code></pre> <p>Even better, operations that involves a single geometry can be called in a simpler form:</p> <pre><code>&gt;&gt;&gt; area = gdf.select(st.area())\n</code></pre>"},{"location":"api-reference/","title":"Overview","text":"Operation Description Available on Input / Output <code>read_file</code> Read OGR supported file format into a GeoDataFrame. <code>root</code> <code>write_file</code> Write the GeoDataFrame to an OGR supported file format. <code>DataFrame</code> <code>write_geojson</code> Serialize to GeoJSON FeatureCollection representation. <code>DataFrame</code> <code>write_ndgeojson</code> Serialize to newline-delimited GeoJSON FeatureCollection representation. <code>DataFrame</code> Creation <code>point</code> Create Point geometries from coordinates. <code>root</code> <code>multipoint</code> Create MultiPoint geometries from list of coordinates. <code>root</code> <code>linestring</code> Create LineString geometries from lists of coordinates. <code>root</code> <code>circularstring</code> Create CircularString geometries from lists of coordinates. <code>root</code> <code>multilinestring</code> Create MultiLineString geometries from lists of lists of coordinates. <code>root</code> <code>polygon</code> Create Polygon geometries from lists of lists of coordinates. <code>root</code> <code>from_wkb</code> Parse geometries from Well-Known Binary (WKB) representation <code>root</code> <code>from_wkt</code> Parse geometries from Well-Known Text (WKT) representation <code>root</code> <code>from_ewkt</code> Parse geometries from Extended Well-Known Text (EWKT) representation <code>root</code> <code>from_geojson</code> Parse geometries from GeoJSON representation. <code>root</code> <code>from_shapely</code> Parse geometries from shapely objects <code>root</code> <code>from_geopandas</code> Create <code>GeoDataFrame</code> or <code>GeoSeries</code> from Geopandas equivalent. <code>root</code> Serialization <code>to_wkt</code> Serialize each geometry as WKT (Well-Known Text). <code>root</code>, <code>Expr</code>, <code>Series</code>, <code>DataFrame</code> <code>to_ewkt</code> Serialize each geometry as EWKT (Extended Well-Known Text). <code>root</code>, <code>Expr</code>, <code>Series</code>, <code>DataFrame</code> <code>to_wkb</code> Serialize each geometry as WKB (Well-Known Binary). <code>root</code>, <code>Expr</code>, <code>Series</code>, <code>DataFrame</code> <code>to_geojson</code> Serialize each geometry as GeoJSON. <code>root</code>, <code>Expr</code>, <code>Series</code>, <code>DataFrame</code> <code>to_dict</code> Convert each geometry to a GeoJSON-like  Python <code>dict</code> object. <code>root</code>, <code>Expr</code>, <code>Series</code>, <code>DataFrame</code> <code>to_shapely</code> Convert each geometry to a Shapely object. <code>root</code>, <code>Expr</code>, <code>Series</code>, <code>DataFrame</code> <code>to_geopandas</code> Convert DataFrame or Series to GeoPandas equivalent. <code>Series</code>, <code>DataFrame</code> <code>to_dicts</code> Convert every row to a Python <code>dict</code> representation of a GeoJSON Feature. <code>DataFrame</code> <code>__geo_interface__</code> Return a Python <code>dict</code> representation of a <code>GeometryCollection</code> or <code>FeatureCollection</code>. <code>Series</code>, <code>DataFrame</code> General operations <code>geometry_type</code> Return the type of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>dimensions</code> Return the inherent dimensionality of each geometry.. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>coordinate_dimension</code> Return the coordinate dimension of each geometry.. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>area</code> Return the area of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>bounds</code> Return the bounds of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>length</code> Return the length of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>minimum_clearance</code> Return the minimum clearance of each geometry.. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>x</code> Return the <code>x</code> value of Point geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>y</code> Return the <code>y</code> value of Point geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>z</code> Return the <code>z</code> value of Point geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>m</code> Return the <code>m</code> value of Point geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>count_coordinates</code> Return the number of coordinates in each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>coordinates</code> Return the coordinates of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>count_geometries</code> Return the number of parts in multipart geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>get_geometry</code> Return the nth part of multipart geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>count_points</code> Return the number of points in LineString geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>get_point</code> Return the nth point of LineString geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>count_interior_rings</code> Return the number of interior rings in Polygon geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>get_interior_ring</code> Return the nth ring of Polygon geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>exterior_ring</code> Return the exterior ring of Polygon geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>interior_rings</code> Return the list of interior rings for Polygon geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>parts</code> Return a list of parts for multipart geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>precision</code> Return the precision of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>set_precision</code> Set the precision of each geometry to a certain grid size. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>distance</code> Return the distance of each geometry to other. <code>Expr</code>, <code>Series</code> <code>hausdorff_distance</code> Return the geometries hausdorff distance to other geometries. <code>Expr</code>, <code>Series</code> <code>frechet_distance</code> Return the geometries frechet distance to other geometries. <code>Expr</code>, <code>Series</code> Projection operations <code>srid</code> Return the SRID of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>set_srid</code> Set the SRID of each geometry to a given value. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>to_srid</code> Transform the coordinates of each geometry into a new CRS. <code>root</code>, <code>Expr</code>, <code>Series</code> Unary predicates <code>has_z</code> Return <code>True</code> for geometries that has <code>z</code> coordinate values. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>has_m</code> Return <code>True</code> for geometries that has <code>m</code> coordinate values. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>is_ccw</code> Return <code>True</code> for linear geometries with counter-clockwise coord sequence. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>is_closed</code> Return <code>True</code> for closed linear geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>is_empty</code> Return <code>True</code> for empty geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>is_ring</code> Return <code>True</code> for ring geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>is_simple</code> Return <code>True</code> for simple geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>is_valid</code> Return <code>True</code> for valid geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>is_valid_reason</code> Return an explanation string for the invalidity of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> Binary predicates <code>crosses</code> Return <code>True</code> when each geometry crosses other. <code>Expr</code>, <code>Series</code> <code>contains</code> Return <code>True</code> when each geometry contains other. <code>Expr</code>, <code>Series</code> <code>contains_properly</code> Return <code>True</code> when each geometry properly contains other. <code>Expr</code>, <code>Series</code> <code>covered_by</code> Return <code>True</code> when each geometry is covered by other. <code>Expr</code>, <code>Series</code> <code>covers</code> Return <code>True</code> when each geometry covers other. <code>Expr</code>, <code>Series</code> <code>disjoint</code> Return <code>True</code> when each geometry is disjoint from other. <code>Expr</code>, <code>Series</code> <code>dwithin</code> Return <code>True</code> when each geometry is within given distance to other. <code>Expr</code>, <code>Series</code> <code>intersects</code> Return <code>True</code> when each geometry intersects other. <code>Expr</code>, <code>Series</code> <code>overlaps</code> Return <code>True</code> when each geometry overlaps other. <code>Expr</code>, <code>Series</code> <code>touches</code> Return <code>True</code> when each geometry touches other. <code>Expr</code>, <code>Series</code> <code>within</code> Return <code>True</code> when each geometry is within other. <code>Expr</code>, <code>Series</code> <code>equals</code> Return <code>True</code> when each geometry is equal to other. <code>Expr</code>, <code>Series</code> <code>equals_exact</code> Return <code>True</code> when each geometry is equal to other. <code>Expr</code>, <code>Series</code> <code>equals_identical</code> Return <code>True</code> when each geometry is equal to other. <code>Expr</code>, <code>Series</code> <code>relate</code> Return the DE-9IM intersection matrix of each geometry with other. <code>Expr</code>, <code>Series</code> <code>relate_pattern</code> Return <code>True</code> when the DE-9IM intersection matrix matches a given pattern. <code>Expr</code>, <code>Series</code> Set operations <code>union</code> Return the union of each geometry with other. <code>Expr</code>, <code>Series</code> <code>unary_union</code> Return the unary union of each geometry. <code>Expr</code>, <code>Series</code> <code>coverage_union</code> Return the coverage union of each geometry with other. <code>Expr</code>, <code>Series</code> <code>intersection</code> Return the intersection of each geometry with other. <code>Expr</code>, <code>Series</code> <code>difference</code> Return the difference of each geometry with other. <code>Expr</code>, <code>Series</code> <code>symmetric_difference</code> Return the symmetric difference of each geometry with other. <code>Expr</code>, <code>Series</code> Constructive operations <code>cast</code> Cast each geometry into a different compatible geometry type. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>multi</code> Cast each geometry into their multipart equivalent. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>boundary</code> Return the topological boundary of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>buffer</code> Return a buffer around each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>offset_curve</code> Return a line at a given distance of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>centroid</code> Return the centroid of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>center</code> Return the center of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>clip_by_rect</code> Clips each geometry by a bounding rectangle. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>convex_hull</code> Return the convex hull of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>concave_hull</code> Return the concave hull of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>segmentize</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>envelope</code> Return the envelope of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>extract_unique_points</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>build_area</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>make_valid</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>normalize</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>node</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>point_on_surface</code> Return a point that intersects each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>remove_repeated_points</code> Remove the repeated points for each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>reverse</code> Reverse the coordinates order of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>simplify</code> Simplify each geometry with a given tolerance. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>force_2d</code> Force the dimensionality of a geometry to 2D. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>force_3d</code> Force the dimensionality of a geometry to 3D. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>flip_coordinates</code> Flip the x and y coordinates of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>minimum_rotated_rectangle</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>snap</code> <code>Expr</code>, <code>Series</code> <code>shortest_line</code> Return the shortest line between each geometry and other. <code>Expr</code>, <code>Series</code> <code>sjoin</code> Perform a spatial join operation with another DataFrame. <code>DataFrame</code>, <code>LazyFrame</code> Affine transforms <code>affine_transform</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>translate</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>rotate</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>scale</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>skew</code> <code>root</code>, <code>Expr</code>, <code>Series</code> LineString operations <code>interpolate</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>project</code> <code>Expr</code>, <code>Series</code> <code>substring</code> Returns the substring of each line starting and ending at the given fractional locations. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>line_merge</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>shared_paths</code> <code>Expr</code>, <code>Series</code> Aggregation <code>total_bounds</code> Return the total bounds of all geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>collect</code> Aggregate geometries into a single collection. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>union_all</code> Return the union of all geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>coverage_union_all</code> Return the coverage union of all geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>intersection_all</code> Return the intersection of all geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>difference_all</code> Return the difference of all geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>symmetric_difference_all</code> Return the symmetric difference of all geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>polygonize</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>voronoi_polygons</code> Return a Voronoi diagram of all geometries vertices. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>delaunay_triangles</code> Return a Delaunay triangulation of all geometries vertices. <code>root</code>, <code>Expr</code>, <code>Series</code> Plotting <code>plot</code> Create a map plot of a GeoSeries or GeoDataFrame. <code>Series</code>, <code>DataFrame</code>"},{"location":"api-reference/columns/","title":"Column Selection","text":""},{"location":"api-reference/columns/#polars_st.geom","title":"polars_st.geom","text":"<pre><code>geom(name: str | Iterable[str] = 'geometry', *more_names: str) -&gt; GeoExpr\n</code></pre> <p>Create a geometry column expression.</p> <p>Alias for     <code>polars.col</code> with type hints for the <code>st</code> namespace.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | Iterable[str]</code>, default:                   <code>'geometry'</code> )           \u2013            <p>The name or datatype of the geometry column(s) to represent. Accepts regular expression input. Regular expressions should start with <code>^</code> and end with <code>$</code>.</p> </li> <li> <code>more_names</code>               (<code>str</code>, default:                   <code>()</code> )           \u2013            <p>Additional names or datatypes of columns to represent, specified as positional arguments.</p> </li> </ul> <p>Examples:</p> <p>Pass a single column name to represent that column:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoSeries(\"my_geom\", [\"POINT(0 0)\"]).to_frame()\n&gt;&gt;&gt; gdf.select(st.geom(\"my_geom\").st.to_wkt())\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 my_geom     \u2502\n\u2502 ---         \u2502\n\u2502 str         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 POINT (0 0) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Call <code>geom</code> without a column name to use the default:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame([\n...     \"POINT(0 0)\",\n...     \"POINT(1 2)\",\n... ])\n&gt;&gt;&gt; gdf.select(st.geom().st.union_all().st.to_wkt())\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 geometry                  \u2502\n\u2502 ---                       \u2502\n\u2502 str                       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 MULTIPOINT ((0 0), (1 2)) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/columns/#polars_st.element","title":"polars_st.element","text":"<pre><code>element() -&gt; GeoExpr\n</code></pre> <p>Alias for <code>polars.element</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame([\n...     \"MULTIPOINT ((0 0), (1 2))\"\n... ])\n&gt;&gt;&gt; gdf.select(st.parts().list.eval(st.element().st.to_wkt()))\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 geometry                       \u2502\n\u2502 ---                            \u2502\n\u2502 list[str]                      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [\"POINT (0 0)\", \"POINT (1 2)\"] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/creation/","title":"Geometry creation","text":""},{"location":"api-reference/creation/#polars_st.point","title":"polars_st.point","text":"<pre><code>point(coords: IntoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Create Point geometries from coordinates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"coords\": [\n...          [0, 1],\n...          [2, 3],\n...     ]\n... })\n&gt;&gt;&gt; df = df.select(geometry=st.point(\"coords\"))\n&gt;&gt;&gt; df.st.to_wkt()\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 geometry    \u2502\n\u2502 ---         \u2502\n\u2502 str         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 POINT (0 1) \u2502\n\u2502 POINT (2 3) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"x\": [0, 1],\n...     \"y\": [0, 2],\n...     \"z\": [0, 3],\n... })\n&gt;&gt;&gt; df = df.select(geometry=st.point(pl.concat_arr(\"x\", \"y\", \"z\")))\n&gt;&gt;&gt; df.st.to_wkt()\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 geometry        \u2502\n\u2502 ---             \u2502\n\u2502 str             \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 POINT Z (0 0 0) \u2502\n\u2502 POINT Z (1 2 3) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/creation/#polars_st.multipoint","title":"polars_st.multipoint","text":"<pre><code>multipoint(coords: IntoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Create MultiPoint geometries from list of coordinates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"coords\": [\n...          [[0, 1],[2, 3]],\n...          [[4, 5],[6, 7]],\n...     ]\n... })\n&gt;&gt;&gt; df = df.select(geometry=st.multipoint(\"coords\"))\n&gt;&gt;&gt; df.st.to_wkt()\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 geometry                  \u2502\n\u2502 ---                       \u2502\n\u2502 str                       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 MULTIPOINT ((0 1), (2 3)) \u2502\n\u2502 MULTIPOINT ((4 5), (6 7)) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/creation/#polars_st.linestring","title":"polars_st.linestring","text":"<pre><code>linestring(coords: IntoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Create LineString geometries from lists of coordinates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"coords\": [\n...         [[0, 1], [2, 3], [4, 5]]\n...     ],\n... })\n&gt;&gt;&gt; df = df.select(geometry=st.linestring(\"coords\"))\n&gt;&gt;&gt; df.st.to_wkt()\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 geometry                   \u2502\n\u2502 ---                        \u2502\n\u2502 str                        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 LINESTRING (0 1, 2 3, 4 5) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"idx\": [0, 0, 1, 1],\n...     \"x\": [0, 1, 3, 5],\n...     \"y\": [0, 2, 4, 6],\n... })\n&gt;&gt;&gt; df = df.group_by(\"idx\").agg(coords=pl.concat_list(\"x\", \"y\"))\n&gt;&gt;&gt; df = df.select(\"idx\", geometry=st.linestring(\"coords\"))\n&gt;&gt;&gt; df.sort(\"idx\").st.to_wkt()\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 idx \u2506 geometry              \u2502\n\u2502 --- \u2506 ---                   \u2502\n\u2502 i64 \u2506 str                   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0   \u2506 LINESTRING (0 0, 1 2) \u2502\n\u2502 1   \u2506 LINESTRING (3 4, 5 6) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/creation/#polars_st.circularstring","title":"polars_st.circularstring","text":"<pre><code>circularstring(coords: IntoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Create CircularString geometries from lists of coordinates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"coords\": [\n...         [[0, 1], [2, 3], [4, 5]]\n...     ],\n... })\n&gt;&gt;&gt; df = df.select(geometry=st.circularstring(\"coords\"))\n&gt;&gt;&gt; df.st.to_wkt()\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 geometry                       \u2502\n\u2502 ---                            \u2502\n\u2502 str                            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 CIRCULARSTRING (0 1, 2 3, 4 5) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/creation/#polars_st.multilinestring","title":"polars_st.multilinestring","text":"<pre><code>multilinestring(coords: IntoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Create MultiLineString geometries from lists of lists of coordinates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"coords\": [\n...         [[[1, 2], [3, 4]],[[5, 6], [7, 8]]]\n...     ]\n... })\n&gt;&gt;&gt; df = df.select(geometry=st.multilinestring(\"coords\"))\n&gt;&gt;&gt; df.st.to_wkt()\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 geometry                        \u2502\n\u2502 ---                             \u2502\n\u2502 str                             \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 MULTILINESTRING ((1 2, 3 4), (\u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/creation/#polars_st.polygon","title":"polars_st.polygon","text":"<pre><code>polygon(coords: IntoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Create Polygon geometries from lists of lists of coordinates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"coords\": [\n...         [[[0, 0], [2, 4], [4, 0], [0, 0]]]\n...     ]\n... })\n&gt;&gt;&gt; df = df.select(geometry=st.polygon(\"coords\"))\n&gt;&gt;&gt; df.st.to_wkt()\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 geometry                       \u2502\n\u2502 ---                            \u2502\n\u2502 str                            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 POLYGON ((0 0, 2 4, 4 0, 0 0)) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/creation/#polars_st.rectangle","title":"polars_st.rectangle","text":"<pre><code>rectangle(bounds: IntoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Create Polygon geometries from bounds.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"bounds\": [\n...         [0.0, 0.0, 1.0, 2.0],\n...         [5.0, 6.0, 7.0, 8.0],\n...     ]\n... })\n&gt;&gt;&gt; df = df.select(geometry=st.rectangle(\"bounds\"))\n&gt;&gt;&gt; df.st.to_wkt()\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 geometry                        \u2502\n\u2502 ---                             \u2502\n\u2502 str                             \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 POLYGON ((0 0, 1 0, 1 2, 0 2, \u2026 \u2502\n\u2502 POLYGON ((5 6, 7 6, 7 8, 5 8, \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/creation/#polars_st.from_wkb","title":"polars_st.from_wkb","text":"<pre><code>from_wkb(expr: IntoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Parse geometries from Well-Known Binary (WKB) representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.read_database(\n...     query=\"SELECT ST_AsEWKB(geom) AS geometry FROM test_data\",\n...     connection=user_conn,\n... )\n&gt;&gt;&gt; gdf = df.select(st.from_wkb(\"geometry\"))\n</code></pre>"},{"location":"api-reference/creation/#polars_st.from_wkt","title":"polars_st.from_wkt","text":"<pre><code>from_wkt(expr: IntoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Parse geometries from Well-Known Text (WKT) representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.Series(\"geometry\", [\n...     \"POINT(0 0)\",\n...     \"POINT(1 2)\",\n... ]).to_frame()\n&gt;&gt;&gt; gdf = df.select(st.from_wkt(\"geometry\"))\n</code></pre>"},{"location":"api-reference/creation/#polars_st.from_ewkt","title":"polars_st.from_ewkt","text":"<pre><code>from_ewkt(expr: IntoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Parse geometries from Extended Well-Known Text (EWKT) representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.Series(\"geometry\", [\n...     \"SRID=4326;POINT(0 0)\",\n...     \"SRID=3857;POINT(1 2)\",\n... ]).to_frame()\n&gt;&gt;&gt; gdf = df.select(st.from_ewkt(\"geometry\"))\n</code></pre>"},{"location":"api-reference/creation/#polars_st.from_geojson","title":"polars_st.from_geojson","text":"<pre><code>from_geojson(expr: IntoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Parse geometries from GeoJSON representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.Series(\"geometry\", [\n...     '{\"type\": \"Point\", \"coordinates\": [0, 0]}',\n...     '{\"type\": \"Point\", \"coordinates\": [1, 2]}',\n... ]).to_frame()\n&gt;&gt;&gt; gdf = df.select(st.from_geojson(\"geometry\"))\n&gt;&gt;&gt; gdf.st.to_wkt()\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 geometry    \u2502\n\u2502 ---         \u2502\n\u2502 str         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 POINT (0 0) \u2502\n\u2502 POINT (1 2) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/creation/#polars_st.from_shapely","title":"polars_st.from_shapely","text":"<pre><code>from_shapely(expr: IntoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Parse geometries from shapely objects.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import shapely\n&gt;&gt;&gt; df = pl.Series(\"geometry\", [\n...     shapely.Point(0, 0),\n...     shapely.Point(1, 2),\n... ], dtype=pl.Object).to_frame()\n&gt;&gt;&gt; df.select(st.from_shapely(\"geometry\")).st.to_wkt()\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 geometry    \u2502\n\u2502 ---         \u2502\n\u2502 str         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 POINT (0 0) \u2502\n\u2502 POINT (1 2) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/creation/#polars_st.from_geopandas","title":"polars_st.from_geopandas","text":"<pre><code>from_geopandas(\n    data: GeoDataFrame,\n    *,\n    schema_overrides: SchemaDict | None = None,\n    rechunk: bool = True,\n    nan_to_null: bool = True,\n    include_index: bool = False\n) -&gt; GeoDataFrame\n</code></pre><pre><code>from_geopandas(\n    data: GeoSeries,\n    *,\n    schema_overrides: SchemaDict | None = None,\n    rechunk: bool = True,\n    nan_to_null: bool = True,\n    include_index: bool = False\n) -&gt; GeoSeries\n</code></pre> <pre><code>from_geopandas(\n    data: GeoDataFrame | GeoSeries,\n    *,\n    schema_overrides: SchemaDict | None = None,\n    rechunk: bool = True,\n    nan_to_null: bool = True,\n    include_index: bool = False\n) -&gt; GeoDataFrame | GeoSeries\n</code></pre> <p>Create DataFrame or Series from Geopandas GeoDataFrame or GeoSeries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import shapely\n&gt;&gt;&gt; import geopandas as gpd\n&gt;&gt;&gt; pd_gdf = gpd.GeoDataFrame({\n...     \"geometry\": [shapely.Point(0, 0), shapely.Point(1, 2)]\n... }, crs=\"EPSG:4326\")\n&gt;&gt;&gt; gdf = st.from_geopandas(pd_gdf)\n</code></pre>"},{"location":"api-reference/creation/#polars_st.read_file","title":"polars_st.read_file","text":"<pre><code>read_file(\n    path_or_buffer: Path | str | bytes,\n    /,\n    layer: int | str | None = None,\n    encoding: str | None = None,\n    columns: Sequence[str] | None = None,\n    read_geometry: bool = True,\n    force_2d: bool = False,\n    skip_features: int = 0,\n    max_features: int | None = None,\n    where: str | None = None,\n    bbox: tuple[float, float, float, float] | None = None,\n    fids: Sequence[int] | None = None,\n    sql: str | None = None,\n    sql_dialect: str | None = None,\n    return_fids: bool = False,\n) -&gt; GeoDataFrame\n</code></pre> <p>Read OGR data source into a GeoDataFrame.</p> <p>IMPORTANT: non-linear geometry types (e.g., MultiSurface) are converted to their linear approximations.</p> <p>Parameters:</p> <ul> <li> <code>path_or_buffer</code>               (<code>Path | str | bytes</code>)           \u2013            <p>A dataset path or URI, or raw buffer.</p> </li> <li> <code>layer</code>               (<code>int | str | None</code>, default:                   <code>None</code> )           \u2013            <p>If an integer is provided, it corresponds to the index of the layer with the data source.  If a string is provided, it must match the name of the layer in the data source.  Defaults to first layer in data source.</p> </li> <li> <code>encoding</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If present, will be used as the encoding for reading string values from the data source, unless encoding can be inferred directly from the data source.</p> </li> <li> <code>columns</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of column names to import from the data source.  Column names must exactly match the names in the data source, and will be returned in the order they occur in the data source.  To avoid reading any columns, pass an empty list-like.</p> </li> <li> <code>read_geometry</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, will read geometry into WKB. If False, geometry will be None. Defaults to <code>True</code>.</p> </li> <li> <code>force_2d</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If the geometry has Z values, setting this to True will cause those to be ignored and 2D geometries to be returned. Defaults to <code>False</code>.</p> </li> <li> <code>skip_features</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Number of features to skip from the beginning of the file before returning features.  Must be less than the total number of features in the file.</p> </li> <li> <code>max_features</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of features to read from the file.  Must be less than the total number of features in the file minus skip_features (if used).</p> </li> <li> <code>where</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Where clause to filter features in layer by attribute values.  Uses a restricted form of SQL WHERE clause, defined here. For examples:</p> <ul> <li><code>\"ISO_A3 = 'CAN'\"</code></li> <li><code>\"POP_EST &gt; 10000000 AND POP_EST &lt; 100000000\"</code></li> </ul> </li> <li> <code>bbox</code>               (<code>tuple[float, float, float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>If present, will be used to filter records whose geometry intersects this box.  This must be in the same CRS as the dataset.  If GEOS is present and used by GDAL, only geometries that intersect this bbox will be returned; if GEOS is not available or not used by GDAL, all geometries with bounding boxes that intersect this bbox will be returned.</p> </li> <li> <code>fids</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Array of integer feature id (FID) values to select. Cannot be combined with other keywords to select a subset (<code>skip_features</code>, <code>max_features</code>, <code>where</code> or <code>bbox</code>). Note that the starting index is driver and file specific (e.g. typically 0 for Shapefile and 1 for GeoPackage, but can still depend on the specific file). The performance of reading a large number of features usings FIDs is also driver specific.</p> </li> <li> <code>sql</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The SQL statement to execute. Look at the sql_dialect parameter for more information on the syntax to use for the query. When combined with other keywords like <code>columns</code>, <code>skip_features</code>, <code>max_features</code>, <code>where</code>, <code>bbox</code>, or <code>mask</code>, those are applied after the SQL query. Be aware that this can have an impact on performance, (e.g. filtering with the <code>bbox</code> or <code>mask</code> keywords may not use spatial indexes). Cannot be combined with the <code>layer</code> or <code>fids</code> keywords.</p> </li> <li> <code>sql_dialect</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The SQL dialect the SQL statement is written in. Possible values:</p> <ul> <li><code>None</code>: if the data source natively supports SQL, its specific SQL dialect     will be used by default (eg. SQLite and Geopackage: <code>SQLITE</code>, PostgreSQL).     If the data source doesn't natively support SQL, the <code>OGRSQL</code> dialect is     the default.</li> <li><code>OGRSQL</code>: can be used on any data source. Performance can suffer     when used on data sources with native support for SQL.</li> <li><code>SQLITE</code>: can be used on any data source. All spatialite_     functions can be used. Performance can suffer on data sources with     native support for SQL, except for Geopackage and SQLite as this is     their native SQL dialect.</li> </ul> </li> <li> <code>return_fids</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, will return the FIDs of the feature that were read.</p> </li> </ul>"},{"location":"api-reference/geodataframe/","title":"GeoDataFrame","text":""},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrame","title":"polars_st.GeoDataFrame","text":"<pre><code>GeoDataFrame(\n    data: FrameInitTypes | None = None,\n    schema: SchemaDefinition | None = None,\n    *,\n    geometry_name: str = \"geometry\",\n    geometry_format: (\n        Literal[\n            \"wkb\",\n            \"wkt\",\n            \"ewkt\",\n            \"geojson\",\n            \"shapely\",\n            \"point\",\n            \"multipoint\",\n            \"linestring\",\n            \"circularstring\",\n            \"multilinestring\",\n            \"polygon\",\n        ]\n        | None\n    ) = None,\n    schema_overrides: SchemaDict | None = None,\n    strict: bool = True,\n    orient: Orientation | None = None,\n    infer_schema_length: int | None = N_INFER_DEFAULT,\n    nan_to_null: bool = False\n)\n</code></pre> <p>               Bases: <code>DataFrame</code></p> <p>Create a new GeoDataFrame.</p> <p><code>GeoDataFrame</code> is used as an alias for <code>pl.DataFrame</code> with type annotations added for the <code>st</code> namespace, and an overriden constructor which will parse the column identified by <code>geometry_name</code> (default <code>\"geometry\"</code>) into a <code>GeoSeries</code>.</p> <p>See <code>pl.DataFrame</code> for parameters documentation.</p> <p>Note</p> <p>Because Polars doesn't support subclassing of their types, calling this constructor will NOT create an instance of <code>GeoDataFrame</code>, but an instance of <code>pl.DataFrame</code>.</p> <p>As a result, instance checks are not permitted on this class to prevent misuse: <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame([\"POINT(0 0)\"])\n&gt;&gt;&gt; type(gdf)\n&lt;class 'polars.dataframe.frame.DataFrame'&gt;\n&gt;&gt;&gt; isinstance(gdf, st.GeoDataFrame)\nTraceback (most recent call last):\n...\nTypeError: instance check on abstract class GeoDataFrame is not allowed\n</code></pre></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame({\n...     \"geometry\": [\n...         \"POINT(0 0)\",\n...         \"POINT(1 2)\",\n...     ]\n... })\n&gt;&gt;&gt; gdf.schema\nSchema({'geometry': Binary})\n</code></pre> <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame(\n...     {\n...         \"geom\": [\n...             '{\"type\": \"Point\", \"coordinates\": [0, 0]}',\n...             '{\"type\": \"Point\", \"coordinates\": [1, 2]}',\n...         ]\n...     },\n...     geometry_name=\"geom\",\n...     geometry_format=\"geojson\",\n... )\n&gt;&gt;&gt; gdf.schema\nSchema({'geom': Binary})\n</code></pre>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrame.st","title":"st  <code>property</code>","text":"<pre><code>st: GeoDataFrameNameSpace\n</code></pre>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace","title":"polars_st.GeoDataFrameNameSpace","text":""},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.__geo_interface__","title":"polars_st.GeoDataFrameNameSpace.__geo_interface__  <code>property</code>","text":"<pre><code>__geo_interface__: dict\n</code></pre> <p>Return a GeoJSON FeatureCollection <code>dict</code> representation of the DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame({\n...     \"geometry\": [\"POINT(0 0)\", \"POINT(1 2)\"],\n...     \"name\": [\"Alice\", \"Bob\"]\n... })\n&gt;&gt;&gt; interface = gdf.st.__geo_interface__\n&gt;&gt;&gt; pprint.pp(interface)\n{'type': 'FeatureCollection',\n 'features': [{'type': 'Feature',\n               'geometry': {'type': 'Point', 'coordinates': [0.0, 0.0]},\n               'properties': {'name': 'Alice'}},\n              {'type': 'Feature',\n               'geometry': {'type': 'Point', 'coordinates': [1.0, 2.0]},\n               'properties': {'name': 'Bob'}}]}\n</code></pre>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.sjoin","title":"polars_st.GeoDataFrameNameSpace.sjoin","text":"<pre><code>sjoin(\n    other: DataFrame,\n    on: str | Expr = \"geometry\",\n    how: JoinStrategy = \"inner\",\n    predicate: Literal[\n        \"intersects_bbox\",\n        \"intersects\",\n        \"within\",\n        \"dwithin\",\n        \"contains\",\n        \"overlaps\",\n        \"crosses\",\n        \"touches\",\n        \"covers\",\n        \"covered_by\",\n        \"contains_properly\",\n    ] = \"intersects\",\n    distance: float | None = None,\n    *,\n    left_on: str | Expr | None = None,\n    right_on: str | Expr | None = None,\n    suffix: str = \"_right\",\n    validate: JoinValidation = \"m:m\",\n    coalesce: bool | None = None\n) -&gt; GeoDataFrame\n</code></pre> <p>Perform a spatial join operation with another DataFrame.</p>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.to_wkt","title":"polars_st.GeoDataFrameNameSpace.to_wkt","text":"<pre><code>to_wkt(\n    *geometry_columns: str,\n    rounding_precision: int | None = 6,\n    trim: bool = True,\n    output_dimension: Literal[2, 3, 4] = 3,\n    old_3d: bool = False\n) -&gt; DataFrame\n</code></pre> <p>Serialize the DataFrame geometry column as WKT.</p> <p>See <code>GeoExprNameSpace.to_wkt</code>.</p>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.to_ewkt","title":"polars_st.GeoDataFrameNameSpace.to_ewkt","text":"<pre><code>to_ewkt(\n    *geometry_columns: str,\n    rounding_precision: int | None = 6,\n    trim: bool = True,\n    output_dimension: Literal[2, 3, 4] = 3,\n    old_3d: bool = False\n) -&gt; DataFrame\n</code></pre> <p>Serialize the DataFrame geometry column as EWKT.</p> <p>See <code>GeoExprNameSpace.to_ewkt</code>.</p>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.to_wkb","title":"polars_st.GeoDataFrameNameSpace.to_wkb","text":"<pre><code>to_wkb(\n    *geometry_columns: str,\n    output_dimension: Literal[2, 3, 4] = 3,\n    byte_order: Literal[0, 1] | None = None,\n    include_srid: bool = False\n) -&gt; DataFrame\n</code></pre> <p>Serialize the DataFrame geometry column as WKB.</p> <p>See <code>GeoExprNameSpace.to_wkb</code>.</p>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.to_geojson","title":"polars_st.GeoDataFrameNameSpace.to_geojson","text":"<pre><code>to_geojson(*geometry_columns: str, indent: int | None = None) -&gt; DataFrame\n</code></pre> <p>Serialize the DataFrame geometry column as GeoJSON.</p> <p>See <code>GeoExprNameSpace.to_geojson</code>.</p>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.to_shapely","title":"polars_st.GeoDataFrameNameSpace.to_shapely","text":"<pre><code>to_shapely(*geometry_columns: str) -&gt; DataFrame\n</code></pre> <p>Convert the DataFrame geometry column to a shapely representation.</p> <p>See <code>GeoExprNameSpace.to_shapely</code>.</p>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.to_dict","title":"polars_st.GeoDataFrameNameSpace.to_dict","text":"<pre><code>to_dict(*geometry_columns: str) -&gt; DataFrame\n</code></pre> <p>Convert the DataFrame geometry column to a GeoJSON-like Python <code>dict</code> representation.</p> <p>See <code>GeoExprNameSpace.to_dict</code>.</p>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.to_dicts","title":"polars_st.GeoDataFrameNameSpace.to_dicts","text":"<pre><code>to_dicts(geometry_name: str = 'geometry') -&gt; list[dict[str, Any]]\n</code></pre> <p>Convert every row to a Python <code>dict</code> representation of a GeoJSON Feature.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame({\n...     \"name\": [\"Alice\", \"Bob\"],\n...     \"location\": [\"POINT(0 0)\", \"POINT(1 2)\"],\n... }, geometry_name=\"location\")\n&gt;&gt;&gt; dicts = gdf.st.to_dicts(\"location\")\n&gt;&gt;&gt; dicts[0]\n{'type': 'Feature', 'geometry': {'type': 'Point', 'coordinates': [0.0, 0.0]}, 'properties': {'name': 'Alice'}}\n</code></pre>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.to_geopandas","title":"polars_st.GeoDataFrameNameSpace.to_geopandas","text":"<pre><code>to_geopandas(\n    *,\n    geometry_name: str = \"geometry\",\n    use_pyarrow_extension_array: bool = False,\n    **kwargs: Any\n) -&gt; GeoDataFrame\n</code></pre> <p>Convert this DataFrame to a geopandas GeoDataFrame.</p>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.write_file","title":"polars_st.GeoDataFrameNameSpace.write_file","text":"<pre><code>write_file(\n    path: str | BytesIO,\n    layer: str | None = None,\n    driver: str | None = None,\n    geometry_name: str = \"geometry\",\n    encoding: str | None = None,\n    append: bool = False,\n    dataset_metadata: dict | None = None,\n    layer_metadata: dict | None = None,\n    metadata: dict | None = None,\n    dataset_options: dict | None = None,\n    layer_options: dict | None = None,\n    **kwargs: dict[str, Any]\n) -&gt; None\n</code></pre> <p>Write the GeoDataFrame to an OGR supported file format.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | BytesIO</code>)           \u2013            <p>path to output file on writeable file system or an io.BytesIO object to allow writing to memory NOTE: support for writing to memory is limited to specific drivers.</p> </li> <li> <code>layer</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>layer name to create.  If writing to memory and layer name is not provided, it layer name will be set to a UUID4 value.</p> </li> <li> <code>driver</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The OGR format driver used to write the vector file. By default attempts to infer driver from path.  Must be provided to write to memory. The available drivers can be listed by calling: <pre><code>&gt;&gt;&gt; import pyogrio\n&gt;&gt;&gt; pyogrio.list_drivers() # doctest: +SKIP\n{..., 'GeoJSON': 'rw', 'GeoJSONSeq': 'rw',...}\n</code></pre></p> </li> <li> <code>geometry_name</code>               (<code>str</code>, default:                   <code>'geometry'</code> )           \u2013            <p>The name of the column in the input data that will be written as the geometry field.</p> </li> <li> <code>encoding</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Only used for the .dbf file of ESRI Shapefiles. If not specified, uses the default locale.</p> </li> <li> <code>append</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the data source specified by path already exists, and the driver supports appending to an existing data source, will cause the data to be appended to the existing records in the data source.  Not supported for writing to in-memory files. NOTE: append support is limited to specific drivers and GDAL versions.</p> </li> <li> <code>dataset_metadata</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Metadata to be stored at the dataset level in the output file; limited to drivers that support writing metadata, such as GPKG, and silently ignored otherwise. Keys and values must be strings.</p> </li> <li> <code>layer_metadata</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Metadata to be stored at the layer level in the output file; limited to drivers that support writing metadata, such as GPKG, and silently ignored otherwise. Keys and values must be strings.</p> </li> <li> <code>metadata</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>alias of layer_metadata</p> </li> <li> <code>dataset_options</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Dataset creation options (format specific) passed to OGR. Specify as a key-value dictionary.</p> </li> <li> <code>layer_options</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Layer creation options (format specific) passed to OGR. Specify as a key-value dictionary.</p> </li> <li> <code>**kwargs</code>               (<code>dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional driver-specific dataset or layer creation options passed to OGR. pyogrio will attempt to automatically pass those keywords either as dataset or as layer creation option based on the known options for the specific driver. Alternatively, you can use the explicit <code>dataset_options</code> or <code>layer_options</code> keywords to manually do this (for example if an option exists as both dataset and layer option).</p> </li> </ul>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.write_geojson","title":"polars_st.GeoDataFrameNameSpace.write_geojson","text":"<pre><code>write_geojson(file: None = None, geometry_name: str = 'geometry') -&gt; str\n</code></pre><pre><code>write_geojson(\n    file: str | Path | IO[bytes] | IO[str], geometry_name: str = \"geometry\"\n) -&gt; None\n</code></pre> <pre><code>write_geojson(\n    file: str | Path | IO[bytes] | IO[str] | None = None,\n    geometry_name: str = \"geometry\",\n) -&gt; str | None\n</code></pre> <p>Serialize to GeoJSON FeatureCollection representation.</p> <p>The result will be invalid if the geometry column contains different geometry types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame({\n...     \"geometry\": [\"POINT(0 0)\", \"POINT(1 2)\"],\n...     \"name\": [\"Alice\", \"Bob\"]\n... })\n&gt;&gt;&gt; geojson = gdf.st.write_geojson()\n&gt;&gt;&gt; print(geojson)\n{\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"geometry\":{\"type\":\"Point\",\"coordinates\":[0.0,0.0]},\"properties\":{\"name\":\"Alice\"}},{\"type\":\"Feature\",\"geometry\":{\"type\":\"Point\",\"coordinates\":[1.0,2.0]},\"properties\":{\"name\":\"Bob\"}}]}\n</code></pre>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.write_ndgeojson","title":"polars_st.GeoDataFrameNameSpace.write_ndgeojson","text":"<pre><code>write_ndgeojson(file: None = None, geometry_name: str = 'geometry') -&gt; str\n</code></pre><pre><code>write_ndgeojson(\n    file: str | Path | IO[bytes] | IO[str], geometry_name: str = \"geometry\"\n) -&gt; None\n</code></pre> <pre><code>write_ndgeojson(\n    file: str | Path | IO[bytes] | IO[str] | None = None,\n    geometry_name: str = \"geometry\",\n) -&gt; str | None\n</code></pre> <p>Serialize to newline-delimited GeoJSON representation.</p> <p>The result will be invalid if the geometry column contains different geometry types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame({\n...     \"geometry\": [\"POINT(0 0)\", \"POINT(1 2)\"],\n...     \"name\": [\"Alice\", \"Bob\"]\n... })\n&gt;&gt;&gt; ndgeojson = gdf.st.write_ndgeojson()\n&gt;&gt;&gt; print(ndgeojson)\n{\"type\":\"Feature\",\"geometry\":{\"type\":\"Point\",\"coordinates\":[0.0,0.0]},\"properties\":{\"name\":\"Alice\"}}\n{\"type\":\"Feature\",\"geometry\":{\"type\":\"Point\",\"coordinates\":[1.0,2.0]},\"properties\":{\"name\":\"Bob\"}}\n</code></pre>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.plot","title":"polars_st.GeoDataFrameNameSpace.plot","text":"<pre><code>plot(\n    geometry_name: str = \"geometry\", **kwargs: Unpack[MarkConfigKwds]\n) -&gt; Chart\n</code></pre> <p>Draw map plot.</p> <p>Polars does not implement plotting logic itself but instead defers to <code>Altair</code>.</p> <p><code>df.st.plot(**kwargs)</code> is shorthand for <code>alt.Chart({\"values\": df.st.to_dicts()}).mark_geoshape(**kwargs).interactive()</code>. Please read Altair GeoShape documentation for available options.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; url = \"https://naciscdn.org/naturalearth/110m/cultural/ne_110m_admin_0_countries.zip\"\n&gt;&gt;&gt; plot = (\n...     st.read_file(url)\n...     .with_columns(st.simplify(tolerance=1))\n...     .st.plot()\n...     .encode(color=\"CONTINENT:N\")\n...     .configure_legend(title=None)\n...     .properties(height=150)\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; import altair as alt\n&gt;&gt;&gt; df = st.GeoDataFrame({\n... \"color\": [\"red\",\"yellow\", \"blue\"],\n... \"geometry\": [\n...     \"POLYGON((0 0, 0 2, 2 2, 2 0, 0 0))\",\n...     \"POLYGON((0 0, 1 2, 2 0, 0 0))\",\n...     \"POINT(2 1)\"\n... ]})\n&gt;&gt;&gt; plot = (\n...     df.st.plot(blend=\"difference\")\n...     .encode(fill=alt.Color(\"color:N\", scale=None))\n...     .project(\"identity\", reflectY=True, pointRadius=100)\n...     .properties(height=200)\n... )\n</code></pre>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.explore","title":"polars_st.GeoDataFrameNameSpace.explore","text":"<pre><code>explore(geometry_name: str = 'geometry') -&gt; Map\n</code></pre>"},{"location":"api-reference/geoexpr/","title":"GeoExpr","text":""},{"location":"api-reference/geoexpr/#polars_st.GeoExpr","title":"polars_st.GeoExpr","text":"<p>               Bases: <code>Expr</code></p> <p><code>GeoExpr</code> is used as an alias for <code>polars.Expr</code> with type annotations added for the <code>st</code> namespace.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExpr.st","title":"st  <code>property</code>","text":"<pre><code>st: GeoExprNameSpace\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace","title":"polars_st.GeoExprNameSpace","text":""},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.geometry_type","title":"polars_st.GeoExprNameSpace.geometry_type","text":"<pre><code>geometry_type() -&gt; Expr\n</code></pre> <p>Return the type of each geometry.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame([\n...     \"POINT(0 0)\",\n...     \"LINESTRING(0 0, 1 2)\",\n...     \"POLYGON((0 0, 1 1, 1 0, 0 0))\"\n... ])\n&gt;&gt;&gt; gdf.select(st.geom().st.geometry_type())\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 geometry   \u2502\n\u2502 ---        \u2502\n\u2502 enum       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Point      \u2502\n\u2502 LineString \u2502\n\u2502 Polygon    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.dimensions","title":"polars_st.GeoExprNameSpace.dimensions","text":"<pre><code>dimensions() -&gt; Expr\n</code></pre> <p>Return the inherent dimensionality of each geometry.</p> <p>The inherent dimension is 0 for points, 1 for linestrings and linearrings,     and 2 for polygons. For geometrycollections it is the max of the containing     elements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame([\n...     \"POINT(0 0)\",\n...     \"LINESTRING(0 0, 1 2)\",\n...     \"POLYGON((0 0, 1 1, 1 0, 0 0))\"\n... ])\n&gt;&gt;&gt; gdf.select(st.geom().st.dimensions())\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 geometry \u2502\n\u2502 ---      \u2502\n\u2502 i32      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0        \u2502\n\u2502 1        \u2502\n\u2502 2        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.coordinate_dimension","title":"polars_st.GeoExprNameSpace.coordinate_dimension","text":"<pre><code>coordinate_dimension() -&gt; Expr\n</code></pre> <p>Return the coordinate dimension (2, 3 or 4) of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.area","title":"polars_st.GeoExprNameSpace.area","text":"<pre><code>area() -&gt; Expr\n</code></pre> <p>Return the area of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.bounds","title":"polars_st.GeoExprNameSpace.bounds","text":"<pre><code>bounds() -&gt; Expr\n</code></pre> <p>Return the bounds of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.length","title":"polars_st.GeoExprNameSpace.length","text":"<pre><code>length() -&gt; Expr\n</code></pre> <p>Return the length of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.minimum_clearance","title":"polars_st.GeoExprNameSpace.minimum_clearance","text":"<pre><code>minimum_clearance() -&gt; Expr\n</code></pre> <p>Return the geometry minimum clearance.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.x","title":"polars_st.GeoExprNameSpace.x","text":"<pre><code>x() -&gt; Expr\n</code></pre> <p>Return the <code>x</code> value of Point geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.y","title":"polars_st.GeoExprNameSpace.y","text":"<pre><code>y() -&gt; Expr\n</code></pre> <p>Return the <code>y</code> value of Point geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.z","title":"polars_st.GeoExprNameSpace.z","text":"<pre><code>z() -&gt; Expr\n</code></pre> <p>Return the <code>z</code> value of Point geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.m","title":"polars_st.GeoExprNameSpace.m","text":"<pre><code>m() -&gt; Expr\n</code></pre> <p>Return the <code>m</code> value of Point geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.count_coordinates","title":"polars_st.GeoExprNameSpace.count_coordinates","text":"<pre><code>count_coordinates() -&gt; Expr\n</code></pre> <p>Return the number of coordinates in each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.coordinates","title":"polars_st.GeoExprNameSpace.coordinates","text":"<pre><code>coordinates(output_dimension: Literal[2, 3] | None = None) -&gt; Expr\n</code></pre> <p>Return the coordinates of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.exterior_ring","title":"polars_st.GeoExprNameSpace.exterior_ring","text":"<pre><code>exterior_ring() -&gt; GeoExpr\n</code></pre> <p>Return the exterior ring of Polygon geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.interior_rings","title":"polars_st.GeoExprNameSpace.interior_rings","text":"<pre><code>interior_rings() -&gt; Expr\n</code></pre> <p>Return the list of interior rings for Polygon geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.count_interior_rings","title":"polars_st.GeoExprNameSpace.count_interior_rings","text":"<pre><code>count_interior_rings() -&gt; Expr\n</code></pre> <p>Return the number of interior rings in Polygon geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.get_interior_ring","title":"polars_st.GeoExprNameSpace.get_interior_ring","text":"<pre><code>get_interior_ring(index: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>Return the nth ring of Polygon geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.count_geometries","title":"polars_st.GeoExprNameSpace.count_geometries","text":"<pre><code>count_geometries() -&gt; Expr\n</code></pre> <p>Return the number of parts in multipart geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.get_geometry","title":"polars_st.GeoExprNameSpace.get_geometry","text":"<pre><code>get_geometry(index: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>Return the nth part of multipart geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.count_points","title":"polars_st.GeoExprNameSpace.count_points","text":"<pre><code>count_points() -&gt; Expr\n</code></pre> <p>Return the number of points in LineString geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.get_point","title":"polars_st.GeoExprNameSpace.get_point","text":"<pre><code>get_point(index: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>Return the nth point of LineString geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.parts","title":"polars_st.GeoExprNameSpace.parts","text":"<pre><code>parts() -&gt; Expr\n</code></pre> <p>Return the list of parts for multipart geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.precision","title":"polars_st.GeoExprNameSpace.precision","text":"<pre><code>precision() -&gt; Expr\n</code></pre> <p>Return the precision of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.set_precision","title":"polars_st.GeoExprNameSpace.set_precision","text":"<pre><code>set_precision(\n    grid_size: IntoNumericExpr,\n    mode: Literal[\"valid_output\", \"no_topo\", \"keep_collapsed\"] = \"valid_output\",\n) -&gt; GeoExpr\n</code></pre> <p>Set the precision of each geometry to a certain grid size.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.distance","title":"polars_st.GeoExprNameSpace.distance","text":"<pre><code>distance(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return the distance from each geometry to other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.hausdorff_distance","title":"polars_st.GeoExprNameSpace.hausdorff_distance","text":"<pre><code>hausdorff_distance(\n    other: IntoGeoExprColumn, densify: float | None = None\n) -&gt; Expr\n</code></pre> <p>Return the hausdorff distance from each geometry to other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.frechet_distance","title":"polars_st.GeoExprNameSpace.frechet_distance","text":"<pre><code>frechet_distance(\n    other: IntoGeoExprColumn, densify: float | None = None\n) -&gt; Expr\n</code></pre> <p>Return the frechet distance from each geometry to other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.srid","title":"polars_st.GeoExprNameSpace.srid","text":"<pre><code>srid() -&gt; Expr\n</code></pre> <p>Return the geometry SRID.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.set_srid","title":"polars_st.GeoExprNameSpace.set_srid","text":"<pre><code>set_srid(srid: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>Set the SRID of each geometry to a given value.</p> <p>Parameters:</p> <ul> <li> <code>srid</code>               (<code>IntoIntegerExpr</code>)           \u2013            <p>The geometry new SRID</p> </li> </ul>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.to_srid","title":"polars_st.GeoExprNameSpace.to_srid","text":"<pre><code>to_srid(srid: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>Transform the coordinates of each geometry into a new CRS.</p> <p>Parameters:</p> <ul> <li> <code>srid</code>               (<code>IntoIntegerExpr</code>)           \u2013            <p>The srid code of the new CRS</p> </li> </ul>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.to_wkt","title":"polars_st.GeoExprNameSpace.to_wkt","text":"<pre><code>to_wkt(\n    rounding_precision: int | None = 6,\n    trim: bool = True,\n    output_dimension: Literal[2, 3, 4] = 3,\n    old_3d: bool = False,\n) -&gt; Expr\n</code></pre> <p>Serialize each geometry as WKT (Well-Known Text).</p> <p>Parameters:</p> <ul> <li> <code>rounding_precision</code>               (<code>int | None</code>, default:                   <code>6</code> )           \u2013            <p>The rounding precision when writing the WKT string. Set to None to indicate the full precision.</p> </li> <li> <code>trim</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, trim unnecessary decimals (trailing zeros).</p> </li> <li> <code>output_dimension</code>               (<code>Literal[2, 3, 4]</code>, default:                   <code>3</code> )           \u2013            <p>The output dimension for the WKT string. Specifying 3 means that up to 3 dimensions will be written but 2D geometries will still be represented as 2D in the WKT string.</p> </li> <li> <code>old_3d</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Enable old style 3D/4D WKT generation. By default, new style 3D/4D WKT (ie. \u201cPOINT Z (10 20 30)\u201d) is returned, but with <code>old_3d=True</code> the WKT will be formatted in the style \u201cPOINT (10 20 30)\u201d.</p> </li> </ul>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.to_ewkt","title":"polars_st.GeoExprNameSpace.to_ewkt","text":"<pre><code>to_ewkt(\n    rounding_precision: int | None = 6,\n    trim: bool = True,\n    output_dimension: Literal[2, 3, 4] = 3,\n    old_3d: bool = False,\n) -&gt; Expr\n</code></pre> <p>Serialize each geometry as EWKT (Extended Well-Known Text).</p> <p>Parameters:</p> <ul> <li> <code>rounding_precision</code>               (<code>int | None</code>, default:                   <code>6</code> )           \u2013            <p>The rounding precision when writing the WKT string. Set to None to indicate the full precision.</p> </li> <li> <code>trim</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, trim unnecessary decimals (trailing zeros).</p> </li> <li> <code>output_dimension</code>               (<code>Literal[2, 3, 4]</code>, default:                   <code>3</code> )           \u2013            <p>The output dimension for the WKT string. Specifying 3 means that up to 3 dimensions will be written but 2D geometries will still be represented as 2D in the WKT string.</p> </li> <li> <code>old_3d</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Enable old style 3D/4D WKT generation. By default, new style 3D/4D WKT (ie. \u201cPOINT Z (10 20 30)\u201d) is returned, but with <code>old_3d=True</code> the WKT will be formatted in the style \u201cPOINT (10 20 30)\u201d.</p> </li> </ul>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.to_wkb","title":"polars_st.GeoExprNameSpace.to_wkb","text":"<pre><code>to_wkb(\n    output_dimension: Literal[2, 3, 4] = 3,\n    byte_order: Literal[0, 1] | None = None,\n    include_srid: bool = False,\n) -&gt; Expr\n</code></pre> <p>Serialize each geometry as WKB (Well-Known Binary).</p> <p>Parameters:</p> <ul> <li> <code>output_dimension</code>           \u2013            <p>The output dimension for the WKB. Specifying 3 means that up to 3 dimensions will be written but 2D geometries will still be represented as 2D in the WKB representation.</p> </li> <li> <code>byte_order</code>               (<code>Literal[0, 1] | None</code>, default:                   <code>None</code> )           \u2013            <p>Defaults to native machine byte order (<code>None</code>). Use 0 to force big endian and 1 for little endian.</p> </li> <li> <code>include_srid</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the SRID is be included in WKB (this is an extension to the OGC WKB specification).</p> </li> </ul>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.to_geojson","title":"polars_st.GeoExprNameSpace.to_geojson","text":"<pre><code>to_geojson(indent: int | None = None) -&gt; Expr\n</code></pre> <p>Serialize each geometry as GeoJSON.</p> <p>Parameters:</p> <ul> <li> <code>indent</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>If indent is not <code>None</code>, then GeoJSON will be pretty-printed. An indent level of 0 will only insert newlines. <code>None</code> (the default) outputs the most compact representation.</p> </li> </ul>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.to_shapely","title":"polars_st.GeoExprNameSpace.to_shapely","text":"<pre><code>to_shapely() -&gt; Expr\n</code></pre> <p>Convert each geometry to a Shapely object.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.to_dict","title":"polars_st.GeoExprNameSpace.to_dict","text":"<pre><code>to_dict() -&gt; Expr\n</code></pre> <p>Convert each geometry to a GeoJSON-like Python <code>dict</code> object.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.cast","title":"polars_st.GeoExprNameSpace.cast","text":"<pre><code>cast(into: IntoExprColumn) -&gt; Expr\n</code></pre> <p>Cast each geometry into a different compatible geometry type.</p> <p>Valid casts are:</p> Source Destination Point MultiPoint MultiPoint LineString, CircularString LineString MultiPoint, CircularString, MultiLineString, MultiCurve CircularString MultiPoint, LineString, MultiLineString, MultiCurve MultiLineString Polygon Polygon MultiPolygon, MultiSurface CurvePolygon MultiSurface Any GeometryCollection"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.multi","title":"polars_st.GeoExprNameSpace.multi","text":"<pre><code>multi() -&gt; Expr\n</code></pre> <p>Cast each geometry into their multipart equivalent.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.has_z","title":"polars_st.GeoExprNameSpace.has_z","text":"<pre><code>has_z() -&gt; Expr\n</code></pre> <p>Return <code>True</code> for each geometry with <code>z</code> coordinate values.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.has_m","title":"polars_st.GeoExprNameSpace.has_m","text":"<pre><code>has_m() -&gt; Expr\n</code></pre> <p>Return <code>True</code> for each geometry with <code>m</code> coordinate values.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.is_ccw","title":"polars_st.GeoExprNameSpace.is_ccw","text":"<pre><code>is_ccw() -&gt; Expr\n</code></pre> <p>Return <code>True</code> for linear geometries with counter-clockwise coord sequence.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.is_closed","title":"polars_st.GeoExprNameSpace.is_closed","text":"<pre><code>is_closed() -&gt; Expr\n</code></pre> <p>Return <code>True</code> for closed linear geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.is_empty","title":"polars_st.GeoExprNameSpace.is_empty","text":"<pre><code>is_empty() -&gt; Expr\n</code></pre> <p>Return <code>True</code> for empty geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.is_ring","title":"polars_st.GeoExprNameSpace.is_ring","text":"<pre><code>is_ring() -&gt; Expr\n</code></pre> <p>Return <code>True</code> for ring geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.is_simple","title":"polars_st.GeoExprNameSpace.is_simple","text":"<pre><code>is_simple() -&gt; Expr\n</code></pre> <p>Return <code>True</code> for simple geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.is_valid","title":"polars_st.GeoExprNameSpace.is_valid","text":"<pre><code>is_valid() -&gt; Expr\n</code></pre> <p>Return <code>True</code> for valid geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.is_valid_reason","title":"polars_st.GeoExprNameSpace.is_valid_reason","text":"<pre><code>is_valid_reason() -&gt; Expr\n</code></pre> <p>Return an explanation string for the invalidity of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.crosses","title":"polars_st.GeoExprNameSpace.crosses","text":"<pre><code>crosses(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry crosses other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.contains","title":"polars_st.GeoExprNameSpace.contains","text":"<pre><code>contains(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry contains other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.contains_properly","title":"polars_st.GeoExprNameSpace.contains_properly","text":"<pre><code>contains_properly(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry properly contains other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.covered_by","title":"polars_st.GeoExprNameSpace.covered_by","text":"<pre><code>covered_by(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry is covered by other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.covers","title":"polars_st.GeoExprNameSpace.covers","text":"<pre><code>covers(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry covers other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.disjoint","title":"polars_st.GeoExprNameSpace.disjoint","text":"<pre><code>disjoint(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry is disjoint from other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.dwithin","title":"polars_st.GeoExprNameSpace.dwithin","text":"<pre><code>dwithin(other: IntoGeoExprColumn, distance: IntoNumericExpr) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry is within given distance to other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.intersects","title":"polars_st.GeoExprNameSpace.intersects","text":"<pre><code>intersects(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry intersects other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.overlaps","title":"polars_st.GeoExprNameSpace.overlaps","text":"<pre><code>overlaps(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry overlaps other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.touches","title":"polars_st.GeoExprNameSpace.touches","text":"<pre><code>touches(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry touches other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.within","title":"polars_st.GeoExprNameSpace.within","text":"<pre><code>within(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry is within other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.equals","title":"polars_st.GeoExprNameSpace.equals","text":"<pre><code>equals(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry is equal to other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.equals_exact","title":"polars_st.GeoExprNameSpace.equals_exact","text":"<pre><code>equals_exact(other: IntoGeoExprColumn, tolerance: float = 0.0) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry is equal to other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.equals_identical","title":"polars_st.GeoExprNameSpace.equals_identical","text":"<pre><code>equals_identical(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry is equal to other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.relate","title":"polars_st.GeoExprNameSpace.relate","text":"<pre><code>relate(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return the DE-9IM intersection matrix of each geometry with other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.relate_pattern","title":"polars_st.GeoExprNameSpace.relate_pattern","text":"<pre><code>relate_pattern(other: IntoGeoExprColumn, pattern: str) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when the DE-9IM intersection matrix of geometry with other matches a given pattern.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.union","title":"polars_st.GeoExprNameSpace.union","text":"<pre><code>union(other: IntoGeoExprColumn, grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>Return the union of each geometry with other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.unary_union","title":"polars_st.GeoExprNameSpace.unary_union","text":"<pre><code>unary_union(grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>Return the unary union of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.coverage_union","title":"polars_st.GeoExprNameSpace.coverage_union","text":"<pre><code>coverage_union() -&gt; GeoExpr\n</code></pre> <p>Return the coverage union of each geometry with other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.intersection","title":"polars_st.GeoExprNameSpace.intersection","text":"<pre><code>intersection(\n    other: IntoGeoExprColumn, grid_size: float | None = None\n) -&gt; GeoExpr\n</code></pre> <p>Return the intersection of each geometry with other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.difference","title":"polars_st.GeoExprNameSpace.difference","text":"<pre><code>difference(other: IntoGeoExprColumn, grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>Return the difference of each geometry with other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.symmetric_difference","title":"polars_st.GeoExprNameSpace.symmetric_difference","text":"<pre><code>symmetric_difference(\n    other: IntoGeoExprColumn, grid_size: float | None = None\n) -&gt; GeoExpr\n</code></pre> <p>Return the symmetric difference of each geometry with other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.boundary","title":"polars_st.GeoExprNameSpace.boundary","text":"<pre><code>boundary() -&gt; GeoExpr\n</code></pre> <p>Return the topological boundary of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.buffer","title":"polars_st.GeoExprNameSpace.buffer","text":"<pre><code>buffer(\n    distance: IntoNumericExpr,\n    quad_segs: int = 8,\n    cap_style: Literal[\"round\", \"square\", \"flat\"] = \"round\",\n    join_style: Literal[\"round\", \"mitre\", \"bevel\"] = \"round\",\n    mitre_limit: float = 5.0,\n    single_sided: bool = False,\n) -&gt; GeoExpr\n</code></pre> <p>Return a buffer around each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.offset_curve","title":"polars_st.GeoExprNameSpace.offset_curve","text":"<pre><code>offset_curve(\n    distance: IntoNumericExpr,\n    quad_segs: int = 8,\n    join_style: Literal[\"round\", \"mitre\", \"bevel\"] = \"round\",\n    mitre_limit: float = 5.0,\n) -&gt; GeoExpr\n</code></pre> <p>Return a line at a given distance of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.centroid","title":"polars_st.GeoExprNameSpace.centroid","text":"<pre><code>centroid() -&gt; GeoExpr\n</code></pre> <p>Return the centroid of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.center","title":"polars_st.GeoExprNameSpace.center","text":"<pre><code>center() -&gt; GeoExpr\n</code></pre> <p>Return the bounding box center of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.clip_by_rect","title":"polars_st.GeoExprNameSpace.clip_by_rect","text":"<pre><code>clip_by_rect(bounds: IntoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Clips each geometry by a bounding rectangle.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.convex_hull","title":"polars_st.GeoExprNameSpace.convex_hull","text":"<pre><code>convex_hull() -&gt; GeoExpr\n</code></pre> <p>Return the convex hull of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.concave_hull","title":"polars_st.GeoExprNameSpace.concave_hull","text":"<pre><code>concave_hull(ratio: float = 0.0, allow_holes: bool = False) -&gt; GeoExpr\n</code></pre> <p>Return the concave hull of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.segmentize","title":"polars_st.GeoExprNameSpace.segmentize","text":"<pre><code>segmentize(max_segment_length: IntoNumericExpr) -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.envelope","title":"polars_st.GeoExprNameSpace.envelope","text":"<pre><code>envelope() -&gt; GeoExpr\n</code></pre> <p>Return the envelope of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.extract_unique_points","title":"polars_st.GeoExprNameSpace.extract_unique_points","text":"<pre><code>extract_unique_points() -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.build_area","title":"polars_st.GeoExprNameSpace.build_area","text":"<pre><code>build_area() -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.make_valid","title":"polars_st.GeoExprNameSpace.make_valid","text":"<pre><code>make_valid() -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.normalize","title":"polars_st.GeoExprNameSpace.normalize","text":"<pre><code>normalize() -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.node","title":"polars_st.GeoExprNameSpace.node","text":"<pre><code>node() -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.point_on_surface","title":"polars_st.GeoExprNameSpace.point_on_surface","text":"<pre><code>point_on_surface() -&gt; GeoExpr\n</code></pre> <p>Return a point that intersects of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.remove_repeated_points","title":"polars_st.GeoExprNameSpace.remove_repeated_points","text":"<pre><code>remove_repeated_points(tolerance: IntoNumericExpr = 0.0) -&gt; GeoExpr\n</code></pre> <p>Remove the repeated points for each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.reverse","title":"polars_st.GeoExprNameSpace.reverse","text":"<pre><code>reverse() -&gt; GeoExpr\n</code></pre> <p>Reverse the coordinates order of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.simplify","title":"polars_st.GeoExprNameSpace.simplify","text":"<pre><code>simplify(tolerance: IntoNumericExpr, preserve_topology: bool = True) -&gt; GeoExpr\n</code></pre> <p>Simplify each geometry with a given tolerance.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.force_2d","title":"polars_st.GeoExprNameSpace.force_2d","text":"<pre><code>force_2d() -&gt; GeoExpr\n</code></pre> <p>Force the dimensionality of a geometry to 2D.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.force_3d","title":"polars_st.GeoExprNameSpace.force_3d","text":"<pre><code>force_3d(z: IntoNumericExpr = 0.0) -&gt; GeoExpr\n</code></pre> <p>Force the dimensionality of a geometry to 3D.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.flip_coordinates","title":"polars_st.GeoExprNameSpace.flip_coordinates","text":"<pre><code>flip_coordinates() -&gt; GeoExpr\n</code></pre> <p>Flip the x and y coordinates of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.minimum_rotated_rectangle","title":"polars_st.GeoExprNameSpace.minimum_rotated_rectangle","text":"<pre><code>minimum_rotated_rectangle() -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.snap","title":"polars_st.GeoExprNameSpace.snap","text":"<pre><code>snap(other: IntoGeoExprColumn, tolerance: IntoNumericExpr) -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.shortest_line","title":"polars_st.GeoExprNameSpace.shortest_line","text":"<pre><code>shortest_line(other: IntoGeoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Return the shortest line between each geometry and other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.affine_transform","title":"polars_st.GeoExprNameSpace.affine_transform","text":"<pre><code>affine_transform(matrix: IntoExprColumn | Sequence[float]) -&gt; GeoExpr\n</code></pre> <p>Apply a 2D or 3D transformation matrix to the coordinates of each geometry.</p> <p>Parameters:</p> <ul> <li> <code>matrix</code>               (<code>IntoExprColumn | Sequence[float]</code>)           \u2013            <p>The transformation matrix to apply to coordinates. Should contains 6 elements for a 2D transform or 12 for a 3D transform. The matrix elements order should be, in order: - <code>m11</code>, <code>m12</code>, <code>m21</code>, <code>m22</code>, <code>tx</code>, <code>ty</code> for 2D transformations - <code>m11</code>, <code>m12</code>, <code>m13</code>, <code>m21</code>, <code>m22</code>, <code>m23</code>, <code>m31</code>, <code>m32</code>, <code>m33</code>, <code>tx</code>, <code>ty</code>, <code>tz</code>     for 3D transformations</p> </li> </ul>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.translate","title":"polars_st.GeoExprNameSpace.translate","text":"<pre><code>translate(\n    x: IntoNumericExpr = 0.0, y: IntoNumericExpr = 0.0, z: IntoNumericExpr = 0.0\n) -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.rotate","title":"polars_st.GeoExprNameSpace.rotate","text":"<pre><code>rotate(\n    angle: IntoNumericExpr,\n    origin: Literal[\"center\", \"centroid\"] | Sequence[float] = \"center\",\n) -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.scale","title":"polars_st.GeoExprNameSpace.scale","text":"<pre><code>scale(\n    x: IntoNumericExpr = 1.0,\n    y: IntoNumericExpr = 1.0,\n    z: IntoNumericExpr = 1.0,\n    origin: Literal[\"center\", \"centroid\"] | Sequence[float] = \"center\",\n) -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.skew","title":"polars_st.GeoExprNameSpace.skew","text":"<pre><code>skew(\n    x: IntoNumericExpr = 0.0,\n    y: IntoNumericExpr = 0.0,\n    z: IntoNumericExpr = 0.0,\n    origin: Literal[\"center\", \"centroid\"] | Sequence[float] = \"center\",\n) -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.interpolate","title":"polars_st.GeoExprNameSpace.interpolate","text":"<pre><code>interpolate(distance: IntoNumericExpr, normalized: bool = False) -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.project","title":"polars_st.GeoExprNameSpace.project","text":"<pre><code>project(other: IntoGeoExprColumn, normalized: bool = False) -&gt; Expr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.substring","title":"polars_st.GeoExprNameSpace.substring","text":"<pre><code>substring(start: IntoNumericExpr, end: IntoNumericExpr) -&gt; GeoExpr\n</code></pre> <p>Returns the substring of each line starting and ending at the given fractional locations.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.line_merge","title":"polars_st.GeoExprNameSpace.line_merge","text":"<pre><code>line_merge(directed: bool = False) -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.shared_paths","title":"polars_st.GeoExprNameSpace.shared_paths","text":"<pre><code>shared_paths(other: IntoGeoExprColumn) -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.total_bounds","title":"polars_st.GeoExprNameSpace.total_bounds","text":"<pre><code>total_bounds() -&gt; Expr\n</code></pre> <p>Return the total bounds of all geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.collect","title":"polars_st.GeoExprNameSpace.collect","text":"<pre><code>collect(into: GeometryType | None = None) -&gt; GeoExpr\n</code></pre> <p>Aggregate geometries into a single collection.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.union_all","title":"polars_st.GeoExprNameSpace.union_all","text":"<pre><code>union_all(grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>Return the union of all geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.coverage_union_all","title":"polars_st.GeoExprNameSpace.coverage_union_all","text":"<pre><code>coverage_union_all() -&gt; GeoExpr\n</code></pre> <p>Return the coverage union of all geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.intersection_all","title":"polars_st.GeoExprNameSpace.intersection_all","text":"<pre><code>intersection_all(grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>Return the intersection of all geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.difference_all","title":"polars_st.GeoExprNameSpace.difference_all","text":"<pre><code>difference_all(grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>Return the difference of all geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.symmetric_difference_all","title":"polars_st.GeoExprNameSpace.symmetric_difference_all","text":"<pre><code>symmetric_difference_all(grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>Return the symmetric difference of all geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.polygonize","title":"polars_st.GeoExprNameSpace.polygonize","text":"<pre><code>polygonize() -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.voronoi_polygons","title":"polars_st.GeoExprNameSpace.voronoi_polygons","text":"<pre><code>voronoi_polygons(\n    tolerance: float = 0.0,\n    extend_to: bytes | None = None,\n    only_edges: bool = False,\n) -&gt; GeoExpr\n</code></pre> <p>Return a Voronoi diagram of all geometries vertices.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.delaunay_triangles","title":"polars_st.GeoExprNameSpace.delaunay_triangles","text":"<pre><code>delaunay_triangles(tolerance: float = 0.0, only_edges: bool = False) -&gt; GeoExpr\n</code></pre> <p>Return a Delaunay triangulation of all geometries vertices.</p>"},{"location":"api-reference/geolazyframe/","title":"GeoLazyFrame","text":""},{"location":"api-reference/geolazyframe/#polars_st.GeoLazyFrame","title":"polars_st.GeoLazyFrame","text":"<p>               Bases: <code>LazyFrame</code></p>"},{"location":"api-reference/geolazyframe/#polars_st.GeoLazyFrame.st","title":"st  <code>property</code>","text":"<pre><code>st: GeoLazyFrameNameSpace\n</code></pre>"},{"location":"api-reference/geolazyframe/#polars_st.GeoLazyFrameNameSpace","title":"polars_st.GeoLazyFrameNameSpace","text":""},{"location":"api-reference/geolazyframe/#polars_st.GeoLazyFrameNameSpace.sjoin","title":"polars_st.GeoLazyFrameNameSpace.sjoin","text":"<pre><code>sjoin(\n    other: LazyFrame,\n    on: str | Expr = \"geometry\",\n    how: JoinStrategy = \"inner\",\n    predicate: Literal[\n        \"intersects_bbox\",\n        \"intersects\",\n        \"within\",\n        \"dwithin\",\n        \"contains\",\n        \"overlaps\",\n        \"crosses\",\n        \"touches\",\n        \"covers\",\n        \"covered_by\",\n        \"contains_properly\",\n    ] = \"intersects\",\n    distance: float | None = None,\n    *,\n    left_on: str | Expr | None = None,\n    right_on: str | Expr | None = None,\n    suffix: str = \"_right\",\n    validate: JoinValidation = \"m:m\",\n    nulls_equal: bool = False,\n    coalesce: bool | None = None,\n    maintain_order: MaintainOrderJoin | None = None,\n    allow_parallel: bool = True,\n    force_parallel: bool = False\n) -&gt; LazyFrame\n</code></pre> <p>Perform a spatial join operation with another LazyFrame.</p>"},{"location":"api-reference/geoseries/","title":"GeoSeries","text":""},{"location":"api-reference/geoseries/#polars_st.GeoSeries","title":"polars_st.GeoSeries","text":"<pre><code>GeoSeries(\n    name: str | ArrayLike | None = None,\n    values: ArrayLike | None = None,\n    dtype: PolarsDataType | None = None,\n    *,\n    strict: bool = True,\n    nan_to_null: bool = False,\n    geometry_format: (\n        Literal[\n            \"wkb\",\n            \"wkt\",\n            \"ewkt\",\n            \"geojson\",\n            \"shapely\",\n            \"point\",\n            \"multipoint\",\n            \"linestring\",\n            \"circularstring\",\n            \"multilinestring\",\n            \"polygon\",\n        ]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>Series</code></p> <p>Create a new GeoSeries.</p> <p><code>GeoSeries</code> is used as an alias for <code>pl.Series</code> with type annotations added for the <code>st</code> namespace, and an overriden constructor which will parse the values into binary EWKB format.</p> <p>You can create a GeoSeries from a list of coordinate arrays, WKB, WKT, EWKT or GeoJSON     strings, or Shapely objects. If <code>geometry_format</code> is not set, the geometries will be     created by infering the correct deserialization operation from its datatype.</p> <p>See <code>pl.Series</code> for parameters documentation.</p> <p>Note</p> <p>Because Polars doesn't support subclassing of their types, calling this constructor will NOT create an instance of <code>GeoSeries</code>, but an instance of <code>pl.Series</code>.</p> <p>As a result, instance checks are not permitted on this class to prevent misuse: <pre><code>&gt;&gt;&gt; s = st.GeoSeries([\"POINT(0 0)\"])\n&gt;&gt;&gt; type(s)\n&lt;class 'polars.series.series.Series'&gt;\n&gt;&gt;&gt; isinstance(s, st.GeoSeries)\nTraceback (most recent call last):\n...\nTypeError: instance check on abstract class GeoSeries is not allowed\n</code></pre></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gs = st.GeoSeries([\n...     \"POINT(0 0)\",\n...     \"POINT(1 2)\",\n... ])\n&gt;&gt;&gt; gs2 = st.GeoSeries([\n...     [0, 0],\n...     [1, 2],\n... ], geometry_format=\"point\")\n&gt;&gt;&gt; gs.equals(gs2)\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; import shapely\n&gt;&gt;&gt; gs = st.GeoSeries([\n...     shapely.Point(0, 0),\n...     shapely.Point(1, 2),\n... ])\n&gt;&gt;&gt; gs2 = st.GeoSeries([\n...     '{\"type\": \"Point\", \"coordinates\": [0, 0]}',\n...     '{\"type\": \"Point\", \"coordinates\": [1, 2]}',\n... ])\n&gt;&gt;&gt; gs.equals(gs2)\nTrue\n</code></pre>"},{"location":"api-reference/geoseries/#polars_st.GeoSeries.st","title":"st  <code>property</code>","text":"<pre><code>st: GeoSeriesNameSpace\n</code></pre>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace","title":"polars_st.GeoSeriesNameSpace","text":""},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.__geo_interface__","title":"polars_st.GeoSeriesNameSpace.__geo_interface__  <code>property</code>","text":"<pre><code>__geo_interface__: dict\n</code></pre> <p>Return a GeoJSON GeometryCollection <code>dict</code> representation of the DataFrame.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.geometry_type","title":"polars_st.GeoSeriesNameSpace.geometry_type","text":"<pre><code>geometry_type() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.geometry_type</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.dimensions","title":"polars_st.GeoSeriesNameSpace.dimensions","text":"<pre><code>dimensions() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.dimensions</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.coordinate_dimension","title":"polars_st.GeoSeriesNameSpace.coordinate_dimension","text":"<pre><code>coordinate_dimension() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.coordinate_dimension</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.area","title":"polars_st.GeoSeriesNameSpace.area","text":"<pre><code>area() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.area</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.bounds","title":"polars_st.GeoSeriesNameSpace.bounds","text":"<pre><code>bounds() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.bounds</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.length","title":"polars_st.GeoSeriesNameSpace.length","text":"<pre><code>length() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.length</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.minimum_clearance","title":"polars_st.GeoSeriesNameSpace.minimum_clearance","text":"<pre><code>minimum_clearance() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.minimum_clearance</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.x","title":"polars_st.GeoSeriesNameSpace.x","text":"<pre><code>x() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.x</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.y","title":"polars_st.GeoSeriesNameSpace.y","text":"<pre><code>y() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.y</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.z","title":"polars_st.GeoSeriesNameSpace.z","text":"<pre><code>z() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.z</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.m","title":"polars_st.GeoSeriesNameSpace.m","text":"<pre><code>m() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.m</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.count_coordinates","title":"polars_st.GeoSeriesNameSpace.count_coordinates","text":"<pre><code>count_coordinates() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.count_coordinates</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.coordinates","title":"polars_st.GeoSeriesNameSpace.coordinates","text":"<pre><code>coordinates(output_dimension: Literal[2, 3] | None = None) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.coordinates</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.exterior_ring","title":"polars_st.GeoSeriesNameSpace.exterior_ring","text":"<pre><code>exterior_ring() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.exterior_ring</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.interior_rings","title":"polars_st.GeoSeriesNameSpace.interior_rings","text":"<pre><code>interior_rings() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.interior_rings</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.count_interior_rings","title":"polars_st.GeoSeriesNameSpace.count_interior_rings","text":"<pre><code>count_interior_rings() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.count_interior_rings</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.get_interior_ring","title":"polars_st.GeoSeriesNameSpace.get_interior_ring","text":"<pre><code>get_interior_ring(index: IntoIntegerExpr) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.get_interior_ring</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.count_geometries","title":"polars_st.GeoSeriesNameSpace.count_geometries","text":"<pre><code>count_geometries() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.count_geometries</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.get_geometry","title":"polars_st.GeoSeriesNameSpace.get_geometry","text":"<pre><code>get_geometry(index: IntoIntegerExpr) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.get_geometry</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.count_points","title":"polars_st.GeoSeriesNameSpace.count_points","text":"<pre><code>count_points() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.count_points</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.get_point","title":"polars_st.GeoSeriesNameSpace.get_point","text":"<pre><code>get_point(index: IntoIntegerExpr) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.get_point</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.parts","title":"polars_st.GeoSeriesNameSpace.parts","text":"<pre><code>parts() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.parts</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.precision","title":"polars_st.GeoSeriesNameSpace.precision","text":"<pre><code>precision() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.precision</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.set_precision","title":"polars_st.GeoSeriesNameSpace.set_precision","text":"<pre><code>set_precision(\n    grid_size: IntoNumericExpr,\n    mode: Literal[\"valid_output\", \"no_topo\", \"keep_collapsed\"] = \"valid_output\",\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.set_precision</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.distance","title":"polars_st.GeoSeriesNameSpace.distance","text":"<pre><code>distance(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.distance</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.hausdorff_distance","title":"polars_st.GeoSeriesNameSpace.hausdorff_distance","text":"<pre><code>hausdorff_distance(\n    other: IntoGeoExprColumn, densify: float | None = None\n) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.hausdorff_distance</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.frechet_distance","title":"polars_st.GeoSeriesNameSpace.frechet_distance","text":"<pre><code>frechet_distance(\n    other: IntoGeoExprColumn, densify: float | None = None\n) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.frechet_distance</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.srid","title":"polars_st.GeoSeriesNameSpace.srid","text":"<pre><code>srid() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.srid</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.set_srid","title":"polars_st.GeoSeriesNameSpace.set_srid","text":"<pre><code>set_srid(srid: IntoIntegerExpr) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.set_srid</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.to_srid","title":"polars_st.GeoSeriesNameSpace.to_srid","text":"<pre><code>to_srid(srid: IntoIntegerExpr) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.to_srid</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.to_wkt","title":"polars_st.GeoSeriesNameSpace.to_wkt","text":"<pre><code>to_wkt(\n    rounding_precision: int | None = 6,\n    trim: bool = True,\n    output_dimension: Literal[2, 3, 4] = 3,\n    old_3d: bool = False,\n) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.to_wkt</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.to_ewkt","title":"polars_st.GeoSeriesNameSpace.to_ewkt","text":"<pre><code>to_ewkt(\n    rounding_precision: int | None = 6,\n    trim: bool = True,\n    output_dimension: Literal[2, 3, 4] = 3,\n    old_3d: bool = False,\n) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.to_ewkt</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.to_wkb","title":"polars_st.GeoSeriesNameSpace.to_wkb","text":"<pre><code>to_wkb(\n    output_dimension: Literal[2, 3, 4] = 3,\n    byte_order: Literal[0, 1] | None = None,\n    include_srid: bool = False,\n) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.to_wkb</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.to_geojson","title":"polars_st.GeoSeriesNameSpace.to_geojson","text":"<pre><code>to_geojson(indent: int | None = None) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.to_geojson</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.to_shapely","title":"polars_st.GeoSeriesNameSpace.to_shapely","text":"<pre><code>to_shapely() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.to_shapely</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.to_dict","title":"polars_st.GeoSeriesNameSpace.to_dict","text":"<pre><code>to_dict() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.to_dict</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.cast","title":"polars_st.GeoSeriesNameSpace.cast","text":"<pre><code>cast(into: IntoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.cast</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.multi","title":"polars_st.GeoSeriesNameSpace.multi","text":"<pre><code>multi() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.multi</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.to_geopandas","title":"polars_st.GeoSeriesNameSpace.to_geopandas","text":"<pre><code>to_geopandas(\n    *, use_pyarrow_extension_array: bool = False, **kwargs: Any\n) -&gt; GeoSeries\n</code></pre> <p>Convert this pl.Series to a geopandas GeoSeries.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.has_z","title":"polars_st.GeoSeriesNameSpace.has_z","text":"<pre><code>has_z() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.has_z</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.has_m","title":"polars_st.GeoSeriesNameSpace.has_m","text":"<pre><code>has_m() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.has_m</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.is_ccw","title":"polars_st.GeoSeriesNameSpace.is_ccw","text":"<pre><code>is_ccw() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.is_ccw</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.is_closed","title":"polars_st.GeoSeriesNameSpace.is_closed","text":"<pre><code>is_closed() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.is_closed</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.is_empty","title":"polars_st.GeoSeriesNameSpace.is_empty","text":"<pre><code>is_empty() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.is_empty</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.is_ring","title":"polars_st.GeoSeriesNameSpace.is_ring","text":"<pre><code>is_ring() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.is_ring</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.is_simple","title":"polars_st.GeoSeriesNameSpace.is_simple","text":"<pre><code>is_simple() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.is_simple</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.is_valid","title":"polars_st.GeoSeriesNameSpace.is_valid","text":"<pre><code>is_valid() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.is_valid</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.is_valid_reason","title":"polars_st.GeoSeriesNameSpace.is_valid_reason","text":"<pre><code>is_valid_reason() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.is_valid_reason</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.crosses","title":"polars_st.GeoSeriesNameSpace.crosses","text":"<pre><code>crosses(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.crosses</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.contains","title":"polars_st.GeoSeriesNameSpace.contains","text":"<pre><code>contains(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.contains</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.contains_properly","title":"polars_st.GeoSeriesNameSpace.contains_properly","text":"<pre><code>contains_properly(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.contains_properly</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.covered_by","title":"polars_st.GeoSeriesNameSpace.covered_by","text":"<pre><code>covered_by(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.covered_by</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.covers","title":"polars_st.GeoSeriesNameSpace.covers","text":"<pre><code>covers(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.covers</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.disjoint","title":"polars_st.GeoSeriesNameSpace.disjoint","text":"<pre><code>disjoint(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.disjoint</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.dwithin","title":"polars_st.GeoSeriesNameSpace.dwithin","text":"<pre><code>dwithin(other: IntoGeoExprColumn, distance: IntoNumericExpr) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.dwithin</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.intersects","title":"polars_st.GeoSeriesNameSpace.intersects","text":"<pre><code>intersects(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.intersects</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.overlaps","title":"polars_st.GeoSeriesNameSpace.overlaps","text":"<pre><code>overlaps(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.overlaps</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.touches","title":"polars_st.GeoSeriesNameSpace.touches","text":"<pre><code>touches(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.touches</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.within","title":"polars_st.GeoSeriesNameSpace.within","text":"<pre><code>within(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.within</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.equals","title":"polars_st.GeoSeriesNameSpace.equals","text":"<pre><code>equals(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.equals</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.equals_exact","title":"polars_st.GeoSeriesNameSpace.equals_exact","text":"<pre><code>equals_exact(other: IntoGeoExprColumn, tolerance: float = 0.0) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.equals_exact</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.equals_identical","title":"polars_st.GeoSeriesNameSpace.equals_identical","text":"<pre><code>equals_identical(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.equals_identical</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.relate","title":"polars_st.GeoSeriesNameSpace.relate","text":"<pre><code>relate(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.relate</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.relate_pattern","title":"polars_st.GeoSeriesNameSpace.relate_pattern","text":"<pre><code>relate_pattern(other: IntoGeoExprColumn, pattern: str) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.relate_pattern</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.union","title":"polars_st.GeoSeriesNameSpace.union","text":"<pre><code>union(other: IntoGeoExprColumn, grid_size: float | None = None) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.union</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.unary_union","title":"polars_st.GeoSeriesNameSpace.unary_union","text":"<pre><code>unary_union(grid_size: float | None = None) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.unary_union</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.coverage_union","title":"polars_st.GeoSeriesNameSpace.coverage_union","text":"<pre><code>coverage_union() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.coverage_union</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.intersection","title":"polars_st.GeoSeriesNameSpace.intersection","text":"<pre><code>intersection(\n    other: IntoGeoExprColumn, grid_size: float | None = None\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.intersection</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.difference","title":"polars_st.GeoSeriesNameSpace.difference","text":"<pre><code>difference(\n    other: IntoGeoExprColumn, grid_size: float | None = None\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.difference</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.symmetric_difference","title":"polars_st.GeoSeriesNameSpace.symmetric_difference","text":"<pre><code>symmetric_difference(\n    other: IntoGeoExprColumn, grid_size: float | None = None\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.symmetric_difference</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.boundary","title":"polars_st.GeoSeriesNameSpace.boundary","text":"<pre><code>boundary() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.boundary</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.buffer","title":"polars_st.GeoSeriesNameSpace.buffer","text":"<pre><code>buffer(\n    distance: IntoNumericExpr,\n    quad_segs: int = 8,\n    cap_style: Literal[\"round\", \"square\", \"flat\"] = \"round\",\n    join_style: Literal[\"round\", \"mitre\", \"bevel\"] = \"round\",\n    mitre_limit: float = 5.0,\n    single_sided: bool = False,\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.buffer</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.offset_curve","title":"polars_st.GeoSeriesNameSpace.offset_curve","text":"<pre><code>offset_curve(\n    distance: IntoNumericExpr,\n    quad_segs: int = 8,\n    join_style: Literal[\"round\", \"mitre\", \"bevel\"] = \"round\",\n    mitre_limit: float = 5.0,\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.offset_curve</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.centroid","title":"polars_st.GeoSeriesNameSpace.centroid","text":"<pre><code>centroid() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.centroid</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.center","title":"polars_st.GeoSeriesNameSpace.center","text":"<pre><code>center() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.center</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.clip_by_rect","title":"polars_st.GeoSeriesNameSpace.clip_by_rect","text":"<pre><code>clip_by_rect(bounds: IntoExprColumn) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.clip_by_rect</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.convex_hull","title":"polars_st.GeoSeriesNameSpace.convex_hull","text":"<pre><code>convex_hull() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.convex_hull</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.concave_hull","title":"polars_st.GeoSeriesNameSpace.concave_hull","text":"<pre><code>concave_hull(ratio: float = 0.0, allow_holes: bool = False) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.concave_hull</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.segmentize","title":"polars_st.GeoSeriesNameSpace.segmentize","text":"<pre><code>segmentize(max_segment_length: IntoNumericExpr) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.segmentize</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.envelope","title":"polars_st.GeoSeriesNameSpace.envelope","text":"<pre><code>envelope() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.envelope</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.extract_unique_points","title":"polars_st.GeoSeriesNameSpace.extract_unique_points","text":"<pre><code>extract_unique_points() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.extract_unique_points</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.build_area","title":"polars_st.GeoSeriesNameSpace.build_area","text":"<pre><code>build_area() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.build_area</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.make_valid","title":"polars_st.GeoSeriesNameSpace.make_valid","text":"<pre><code>make_valid() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.make_valid</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.normalize","title":"polars_st.GeoSeriesNameSpace.normalize","text":"<pre><code>normalize() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.normalize</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.node","title":"polars_st.GeoSeriesNameSpace.node","text":"<pre><code>node() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.node</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.point_on_surface","title":"polars_st.GeoSeriesNameSpace.point_on_surface","text":"<pre><code>point_on_surface() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.point_on_surface</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.remove_repeated_points","title":"polars_st.GeoSeriesNameSpace.remove_repeated_points","text":"<pre><code>remove_repeated_points(tolerance: IntoNumericExpr = 0.0) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.remove_repeated_points</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.reverse","title":"polars_st.GeoSeriesNameSpace.reverse","text":"<pre><code>reverse() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.reverse</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.simplify","title":"polars_st.GeoSeriesNameSpace.simplify","text":"<pre><code>simplify(\n    tolerance: IntoNumericExpr, preserve_topology: bool = True\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.simplify</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.force_2d","title":"polars_st.GeoSeriesNameSpace.force_2d","text":"<pre><code>force_2d() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.force_2d</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.force_3d","title":"polars_st.GeoSeriesNameSpace.force_3d","text":"<pre><code>force_3d(z: IntoNumericExpr = 0.0) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.force_3d</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.flip_coordinates","title":"polars_st.GeoSeriesNameSpace.flip_coordinates","text":"<pre><code>flip_coordinates() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.flip_coordinates</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.minimum_rotated_rectangle","title":"polars_st.GeoSeriesNameSpace.minimum_rotated_rectangle","text":"<pre><code>minimum_rotated_rectangle() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.minimum_rotated_rectangle</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.snap","title":"polars_st.GeoSeriesNameSpace.snap","text":"<pre><code>snap(other: IntoGeoExprColumn, tolerance: IntoNumericExpr) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.snap</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.shortest_line","title":"polars_st.GeoSeriesNameSpace.shortest_line","text":"<pre><code>shortest_line(other: IntoGeoExprColumn) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.shortest_line</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.affine_transform","title":"polars_st.GeoSeriesNameSpace.affine_transform","text":"<pre><code>affine_transform(matrix: IntoExprColumn | Sequence[float]) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.affine_transform</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.translate","title":"polars_st.GeoSeriesNameSpace.translate","text":"<pre><code>translate(\n    x: IntoNumericExpr = 0.0, y: IntoNumericExpr = 0.0, z: IntoNumericExpr = 0.0\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.translate</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.rotate","title":"polars_st.GeoSeriesNameSpace.rotate","text":"<pre><code>rotate(\n    angle: IntoNumericExpr,\n    origin: Literal[\"center\", \"centroid\"] | Sequence[float] = \"center\",\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.rotate</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.scale","title":"polars_st.GeoSeriesNameSpace.scale","text":"<pre><code>scale(\n    x: IntoNumericExpr = 1.0,\n    y: IntoNumericExpr = 1.0,\n    z: IntoNumericExpr = 1.0,\n    origin: Literal[\"center\", \"centroid\"] | Sequence[float] = \"center\",\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.scale</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.skew","title":"polars_st.GeoSeriesNameSpace.skew","text":"<pre><code>skew(\n    x: IntoNumericExpr = 0.0,\n    y: IntoNumericExpr = 0.0,\n    z: IntoNumericExpr = 0.0,\n    origin: Literal[\"center\", \"centroid\"] | Sequence[float] = \"center\",\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.skew</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.interpolate","title":"polars_st.GeoSeriesNameSpace.interpolate","text":"<pre><code>interpolate(distance: IntoNumericExpr, normalized: bool = False) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.interpolate</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.project","title":"polars_st.GeoSeriesNameSpace.project","text":"<pre><code>project(other: IntoGeoExprColumn, normalized: bool = False) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.project</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.substring","title":"polars_st.GeoSeriesNameSpace.substring","text":"<pre><code>substring(start: IntoNumericExpr, end: IntoNumericExpr) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.substring</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.line_merge","title":"polars_st.GeoSeriesNameSpace.line_merge","text":"<pre><code>line_merge(directed: bool = False) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.line_merge</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.shared_paths","title":"polars_st.GeoSeriesNameSpace.shared_paths","text":"<pre><code>shared_paths(other: IntoGeoExprColumn) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.shared_paths</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.total_bounds","title":"polars_st.GeoSeriesNameSpace.total_bounds","text":"<pre><code>total_bounds() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.total_bounds</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.collect","title":"polars_st.GeoSeriesNameSpace.collect","text":"<pre><code>collect(into: GeometryType | None = None) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.collect</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.union_all","title":"polars_st.GeoSeriesNameSpace.union_all","text":"<pre><code>union_all(grid_size: float | None = None) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.union_all</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.coverage_union_all","title":"polars_st.GeoSeriesNameSpace.coverage_union_all","text":"<pre><code>coverage_union_all() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.coverage_union_all</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.intersection_all","title":"polars_st.GeoSeriesNameSpace.intersection_all","text":"<pre><code>intersection_all(grid_size: float | None = None) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.intersection_all</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.difference_all","title":"polars_st.GeoSeriesNameSpace.difference_all","text":"<pre><code>difference_all(grid_size: float | None = None) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.difference_all</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.symmetric_difference_all","title":"polars_st.GeoSeriesNameSpace.symmetric_difference_all","text":"<pre><code>symmetric_difference_all(grid_size: float | None = None) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.symmetric_difference_all</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.polygonize","title":"polars_st.GeoSeriesNameSpace.polygonize","text":"<pre><code>polygonize() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.polygonize</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.voronoi_polygons","title":"polars_st.GeoSeriesNameSpace.voronoi_polygons","text":"<pre><code>voronoi_polygons(\n    tolerance: float = 0.0,\n    extend_to: bytes | None = None,\n    only_edges: bool = False,\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.voronoi_polygons</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.delaunay_triangles","title":"polars_st.GeoSeriesNameSpace.delaunay_triangles","text":"<pre><code>delaunay_triangles(\n    tolerance: float = 0.0, only_edges: bool = False\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.delaunay_triangles</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.plot","title":"polars_st.GeoSeriesNameSpace.plot","text":"<pre><code>plot(**kwargs: Unpack[MarkConfigKwds]) -&gt; Chart\n</code></pre> <p>Draw map plot.</p> <p>Polars does not implement plotting logic itself but instead defers to <code>Altair</code>.</p> <p><code>df.st.plot(**kwargs)</code> is shorthand for <code>alt.Chart(df).mark_geoshape(**kwargs).interactive()</code>. Please read Altair GeoShape documentation for available options.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.explore","title":"polars_st.GeoSeriesNameSpace.explore","text":"<pre><code>explore() -&gt; Map\n</code></pre>"},{"location":"api-reference/sugar/","title":"Expression Shorthand","text":"<p>When a function only involves one geometry column, such as <code>area</code> or <code>buffer</code>, it is possible to call that function directly from the <code>polars_st</code> module, allowing us to write: <code>gdf.select(st.area())</code> instead of <code>gdf.select(st.geom().st.area())</code>.</p> <p>The following functions can be used that way:</p>"},{"location":"api-reference/sugar/#polars_st.geometry_type","title":"polars_st.geometry_type","text":"<pre><code>geometry_type(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.geometry_type()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.dimensions","title":"polars_st.dimensions","text":"<pre><code>dimensions(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.dimensions()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.coordinate_dimension","title":"polars_st.coordinate_dimension","text":"<pre><code>coordinate_dimension(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.coordinate_dimension()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.area","title":"polars_st.area","text":"<pre><code>area(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.area()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.bounds","title":"polars_st.bounds","text":"<pre><code>bounds(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.bounds()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.length","title":"polars_st.length","text":"<pre><code>length(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.length()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.minimum_clearance","title":"polars_st.minimum_clearance","text":"<pre><code>minimum_clearance(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.minimum_clearance()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.x","title":"polars_st.x","text":"<pre><code>x(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.x()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.y","title":"polars_st.y","text":"<pre><code>y(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.y()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.z","title":"polars_st.z","text":"<pre><code>z(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.z()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.m","title":"polars_st.m","text":"<pre><code>m(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.m()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.count_coordinates","title":"polars_st.count_coordinates","text":"<pre><code>count_coordinates(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.count_coordinates()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.coordinates","title":"polars_st.coordinates","text":"<pre><code>coordinates(\n    *columns: str, output_dimension: Literal[2, 3] | None = None\n) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.coordinates(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.count_geometries","title":"polars_st.count_geometries","text":"<pre><code>count_geometries(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.count_geometries()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.get_geometry","title":"polars_st.get_geometry","text":"<pre><code>get_geometry(*columns: str, index: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.get_geometry(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.count_points","title":"polars_st.count_points","text":"<pre><code>count_points(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.count_points()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.get_point","title":"polars_st.get_point","text":"<pre><code>get_point(*columns: str, index: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.get_point(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.exterior_ring","title":"polars_st.exterior_ring","text":"<pre><code>exterior_ring(*columns: str) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.exterior_ring()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.interior_rings","title":"polars_st.interior_rings","text":"<pre><code>interior_rings(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.interior_rings()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.count_interior_rings","title":"polars_st.count_interior_rings","text":"<pre><code>count_interior_rings(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.count_interior_rings()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.get_interior_ring","title":"polars_st.get_interior_ring","text":"<pre><code>get_interior_ring(*columns: str, index: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.get_interior_ring(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.parts","title":"polars_st.parts","text":"<pre><code>parts(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.parts()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.precision","title":"polars_st.precision","text":"<pre><code>precision(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.precision()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.set_precision","title":"polars_st.set_precision","text":"<pre><code>set_precision(\n    *columns: str,\n    grid_size: IntoNumericExpr,\n    mode: Literal[\"valid_output\", \"no_topo\", \"keep_collapsed\"] = \"valid_output\"\n) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.set_precision(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.srid","title":"polars_st.srid","text":"<pre><code>srid(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.srid()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.set_srid","title":"polars_st.set_srid","text":"<pre><code>set_srid(*columns: str, srid: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.set_srid(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.to_srid","title":"polars_st.to_srid","text":"<pre><code>to_srid(*columns: str, srid: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.to_srid(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.to_wkt","title":"polars_st.to_wkt","text":"<pre><code>to_wkt(\n    *columns: str,\n    rounding_precision: int | None = 6,\n    trim: bool = True,\n    output_dimension: Literal[2, 3, 4] = 3,\n    old_3d: bool = False\n) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.to_wkt(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.to_ewkt","title":"polars_st.to_ewkt","text":"<pre><code>to_ewkt(\n    *columns: str,\n    rounding_precision: int | None = 6,\n    trim: bool = True,\n    output_dimension: Literal[2, 3, 4] = 3,\n    old_3d: bool = False\n) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.to_ewkt(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.to_wkb","title":"polars_st.to_wkb","text":"<pre><code>to_wkb(\n    *columns: str,\n    output_dimension: Literal[2, 3, 4] = 3,\n    byte_order: Literal[0, 1] | None = None,\n    include_srid: bool = False\n) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.to_wkb(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.to_geojson","title":"polars_st.to_geojson","text":"<pre><code>to_geojson(*columns: str, indent: int | None = None) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.to_geojson(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.to_shapely","title":"polars_st.to_shapely","text":"<pre><code>to_shapely(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.to_shapely()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.to_dict","title":"polars_st.to_dict","text":"<pre><code>to_dict(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.to_dict()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.cast","title":"polars_st.cast","text":"<pre><code>cast(*columns: str, into: IntoExprColumn) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.cast(into)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.multi","title":"polars_st.multi","text":"<pre><code>multi(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.multi()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.has_z","title":"polars_st.has_z","text":"<pre><code>has_z(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.has_z()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.has_m","title":"polars_st.has_m","text":"<pre><code>has_m(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.has_m()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.is_ccw","title":"polars_st.is_ccw","text":"<pre><code>is_ccw(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.is_ccw()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.is_closed","title":"polars_st.is_closed","text":"<pre><code>is_closed(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.is_closed()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.is_empty","title":"polars_st.is_empty","text":"<pre><code>is_empty(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.is_empty()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.is_ring","title":"polars_st.is_ring","text":"<pre><code>is_ring(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.is_ring()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.is_simple","title":"polars_st.is_simple","text":"<pre><code>is_simple(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.is_simple()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.is_valid","title":"polars_st.is_valid","text":"<pre><code>is_valid(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.is_valid()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.is_valid_reason","title":"polars_st.is_valid_reason","text":"<pre><code>is_valid_reason(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.is_valid_reason()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.unary_union","title":"polars_st.unary_union","text":"<pre><code>unary_union(*columns: str, grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.unary_union(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.coverage_union","title":"polars_st.coverage_union","text":"<pre><code>coverage_union(*columns: str) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.coverage_union()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.boundary","title":"polars_st.boundary","text":"<pre><code>boundary(*columns: str) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.boundary()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.buffer","title":"polars_st.buffer","text":"<pre><code>buffer(\n    *columns: str,\n    distance: IntoNumericExpr,\n    quad_segs: int = 8,\n    cap_style: Literal[\"round\", \"square\", \"flat\"] = \"round\",\n    join_style: Literal[\"round\", \"mitre\", \"bevel\"] = \"round\",\n    mitre_limit: float = 5.0,\n    single_sided: bool = False\n) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.buffer(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.offset_curve","title":"polars_st.offset_curve","text":"<pre><code>offset_curve(\n    *columns: str,\n    distance: IntoNumericExpr,\n    quad_segs: int = 8,\n    join_style: Literal[\"round\", \"mitre\", \"bevel\"] = \"round\",\n    mitre_limit: float = 5.0\n) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.offset_curve(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.centroid","title":"polars_st.centroid","text":"<pre><code>centroid(*columns: str) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.centroid()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.center","title":"polars_st.center","text":"<pre><code>center(*columns: str) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.center()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.clip_by_rect","title":"polars_st.clip_by_rect","text":"<pre><code>clip_by_rect(*columns: str, bounds: IntoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.clip_by_rect(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.convex_hull","title":"polars_st.convex_hull","text":"<pre><code>convex_hull(*columns: str) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.convex_hull()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.concave_hull","title":"polars_st.concave_hull","text":"<pre><code>concave_hull(\n    *columns: str, ratio: float = 0.0, allow_holes: bool = False\n) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.concave_hull(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.segmentize","title":"polars_st.segmentize","text":"<pre><code>segmentize(*columns: str, max_segment_length: IntoNumericExpr) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.segmentize(max_segment_length)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.envelope","title":"polars_st.envelope","text":"<pre><code>envelope(*columns: str) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.envelope()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.extract_unique_points","title":"polars_st.extract_unique_points","text":"<pre><code>extract_unique_points(*columns: str) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.extract_unique_points()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.build_area","title":"polars_st.build_area","text":"<pre><code>build_area(*columns: str) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.build_area()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.make_valid","title":"polars_st.make_valid","text":"<pre><code>make_valid(*columns: str) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.make_valid()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.normalize","title":"polars_st.normalize","text":"<pre><code>normalize(*columns: str) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.normalize()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.node","title":"polars_st.node","text":"<pre><code>node(*columns: str) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.node()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.point_on_surface","title":"polars_st.point_on_surface","text":"<pre><code>point_on_surface(*columns: str) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.point_on_surface()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.remove_repeated_points","title":"polars_st.remove_repeated_points","text":"<pre><code>remove_repeated_points(\n    *columns: str, tolerance: IntoNumericExpr = 0.0\n) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.remove_repeated_points(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.reverse","title":"polars_st.reverse","text":"<pre><code>reverse(*columns: str) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.reverse()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.simplify","title":"polars_st.simplify","text":"<pre><code>simplify(\n    *columns: str, tolerance: IntoNumericExpr, preserve_topology: bool = True\n) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.simplify(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.force_2d","title":"polars_st.force_2d","text":"<pre><code>force_2d(*columns: str) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.force_2d()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.force_3d","title":"polars_st.force_3d","text":"<pre><code>force_3d(*columns: str, z: IntoNumericExpr = 0.0) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.force_3d(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.flip_coordinates","title":"polars_st.flip_coordinates","text":"<pre><code>flip_coordinates(*columns: str) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.flip_coordinates()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.minimum_rotated_rectangle","title":"polars_st.minimum_rotated_rectangle","text":"<pre><code>minimum_rotated_rectangle(*columns: str) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.minimum_rotated_rectangle()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.affine_transform","title":"polars_st.affine_transform","text":"<pre><code>affine_transform(\n    *columns: str, matrix: IntoExprColumn | Sequence[float]\n) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.affine_transform(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.translate","title":"polars_st.translate","text":"<pre><code>translate(\n    *columns: str,\n    x: IntoNumericExpr = 0.0,\n    y: IntoNumericExpr = 0.0,\n    z: IntoNumericExpr = 0.0\n) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.translate(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.rotate","title":"polars_st.rotate","text":"<pre><code>rotate(\n    *columns: str,\n    angle: IntoNumericExpr,\n    origin: Literal[\"center\", \"centroid\"] | Sequence[float] = \"center\"\n) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.rotate(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.scale","title":"polars_st.scale","text":"<pre><code>scale(\n    *columns: str,\n    x: IntoNumericExpr = 1.0,\n    y: IntoNumericExpr = 1.0,\n    z: IntoNumericExpr = 1.0,\n    origin: Literal[\"center\", \"centroid\"] | Sequence[float] = \"center\"\n) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.scale(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.skew","title":"polars_st.skew","text":"<pre><code>skew(\n    *columns: str,\n    x: IntoNumericExpr = 0.0,\n    y: IntoNumericExpr = 0.0,\n    z: IntoNumericExpr = 0.0,\n    origin: Literal[\"center\", \"centroid\"] | Sequence[float] = \"center\"\n) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.skew(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.interpolate","title":"polars_st.interpolate","text":"<pre><code>interpolate(\n    *columns: str, distance: IntoNumericExpr, normalized: bool = False\n) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.interpolate()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.substring","title":"polars_st.substring","text":"<pre><code>substring(\n    *columns: str, start: IntoNumericExpr, end: IntoNumericExpr\n) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.substring(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.line_merge","title":"polars_st.line_merge","text":"<pre><code>line_merge(*columns: str, directed: bool = False) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.line_merge()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.total_bounds","title":"polars_st.total_bounds","text":"<pre><code>total_bounds(*columns: str) -&gt; Expr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.total_bounds()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.collect","title":"polars_st.collect","text":"<pre><code>collect(*columns: str, into: GeometryType | None = None) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.collect()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.union_all","title":"polars_st.union_all","text":"<pre><code>union_all(*columns: str, grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.union_all(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.coverage_union_all","title":"polars_st.coverage_union_all","text":"<pre><code>coverage_union_all(*columns: str) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.coverage_union_all()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.intersection_all","title":"polars_st.intersection_all","text":"<pre><code>intersection_all(*columns: str, grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.intersection_all()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.difference_all","title":"polars_st.difference_all","text":"<pre><code>difference_all(*columns: str, grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.difference_all(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.symmetric_difference_all","title":"polars_st.symmetric_difference_all","text":"<pre><code>symmetric_difference_all(\n    *columns: str, grid_size: float | None = None\n) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.symmetric_difference_all(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.polygonize","title":"polars_st.polygonize","text":"<pre><code>polygonize(*columns: str) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.polygonize()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.voronoi_polygons","title":"polars_st.voronoi_polygons","text":"<pre><code>voronoi_polygons(\n    *columns: str,\n    tolerance: float = 0.0,\n    extend_to: bytes | None = None,\n    only_edges: bool = False\n) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.voronoi_polygons(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.delaunay_triangles","title":"polars_st.delaunay_triangles","text":"<pre><code>delaunay_triangles(\n    *columns: str, tolerance: float = 0.0, only_edges: bool = False\n) -&gt; GeoExpr\n</code></pre> <p>Syntactic sugar for <code>st.geom(columns).st.delaunay_triangles(...)</code>.</p>"},{"location":"api-reference/typing/","title":"Typing","text":""},{"location":"api-reference/typing/#polars_st.typing.ArrayLike","title":"polars_st.typing.ArrayLike  <code>module-attribute</code>","text":"<pre><code>ArrayLike = Union[\n    Sequence[Any],\n    Series,\n    Array,\n    ChunkedArray,\n    ndarray[Any, Any],\n    Series,\n    DatetimeIndex,\n    ArrowArrayExportable,\n    ArrowStreamExportable,\n]\n</code></pre>"},{"location":"api-reference/typing/#polars_st.typing.IntoExprColumn","title":"polars_st.typing.IntoExprColumn  <code>module-attribute</code>","text":"<pre><code>IntoExprColumn: TypeAlias = Expr | Series | str\n</code></pre>"},{"location":"api-reference/typing/#polars_st.typing.IntoGeoExprColumn","title":"polars_st.typing.IntoGeoExprColumn  <code>module-attribute</code>","text":"<pre><code>IntoGeoExprColumn: TypeAlias = IntoExprColumn\n</code></pre>"},{"location":"api-reference/typing/#polars_st.typing.IntoIntegerExpr","title":"polars_st.typing.IntoIntegerExpr  <code>module-attribute</code>","text":"<pre><code>IntoIntegerExpr: TypeAlias = IntoExprColumn | int\n</code></pre>"},{"location":"api-reference/typing/#polars_st.typing.IntoNumericExpr","title":"polars_st.typing.IntoNumericExpr  <code>module-attribute</code>","text":"<pre><code>IntoNumericExpr: TypeAlias = IntoExprColumn | int | float\n</code></pre>"}]}