{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installing-polars-st","title":"Installing polars-st","text":"<pre><code>pip install polars-st\n</code></pre>"},{"location":"#basics","title":"Basics","text":"<p><code>polars-st</code> provides geometry operations under the namespace <code>st</code> on Polars <code>Expr</code>, <code>Series</code>, <code>DataFrame</code> and  <code>LazyFrame</code>. Functions used to read files or parse geometries are available at the module root. Here's a basic example:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import polars_st as st\n&gt;&gt;&gt; df = pl.DataFrame({\n...     \"wkt\": [\n...         \"POINT(0 0)\",\n...         \"POINT(1 2)\",\n...     ]\n... })\n&gt;&gt;&gt; gdf = df.select(geometry=st.from_wkt(\"geometry\"))\n&gt;&gt;&gt; area = gdf.select(pl.col(\"geometry\").st.area())\n</code></pre> <p>If you have type checking enabled, you might face this error: <code>Cannot access member \u00ab st \u00bb for class  \u00ab Expr \u00bb</code>. In order to support autocompletions and type checking for the <code>st</code> namespace, <code>polars-st</code> provides a utility function <code>st.geom</code>, with the same signature as <code>pl.col</code>, but which returns <code>GeoExpr</code> instead of <code>Expr</code>. <code>GeoExpr</code> is (kinda) just a type alias to polars <code>Expr</code> with type annotations added for the <code>st</code> namespace. It is therefore recommended that you use <code>st.geom</code> instead of <code>pl.col</code> to query geometry columns.</p> <p>In addition to type checking, <code>st.geom</code> also has a trick up its sleeve: assuming the geometry column matches the default name defined in <code>st.Config</code> (the built-in default is \"geometry\"), you can even omit typing the column name entirely:</p> <pre><code>&gt;&gt;&gt; area = gdf.select(st.geom().st.area())\n</code></pre> <p>Even better, operations that involves a single geometry can be called in a simpler form:</p> <pre><code>&gt;&gt;&gt; area = gdf.select(st.area())\n</code></pre> <p>The default geometry column name can be configured with <code>st.Config</code>. Like <code>polars.Config</code>, <code>st.Config</code> can be used as a context manager, a function context decorator, or as a global configuration object.</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoSeries(\"my_geometry\", [\"POINT(1 2)\"]).to_frame()\n&gt;&gt;&gt; with st.Config(geometry_column=\"my_geometry\"):\n...     x = gdf.select(st.x())\n&gt;&gt;&gt; x\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 my_geometry \u2502\n\u2502 ---         \u2502\n\u2502 f64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/","title":"Overview","text":"Operation Description Available on Input / Output <code>read_file</code> Read OGR supported file format into a GeoDataFrame. <code>root</code> <code>write_file</code> Write the GeoDataFrame to an OGR supported file format. <code>DataFrame</code> <code>write_geojson</code> Serialize to GeoJSON FeatureCollection representation. <code>DataFrame</code> <code>write_geojsonseq</code> Serialize to newline delimited GeoJSON FeatureCollection representation. <code>DataFrame</code> Parsing <code>from_wkb</code> Parse geometries from Well-Known Binary (WKB) representation <code>root</code> <code>from_wkt</code> Parse geometries from Well-Known Text (WKT) representation <code>root</code> <code>from_ewkt</code> Parse geometries from Extended Well-Known Text (EWKT) representation <code>root</code> <code>from_geojson</code> Parse geometries from GeoJSON representation. <code>root</code> <code>from_xy</code> Create points from x, y (, z) coordinates <code>root</code> <code>from_shapely</code> Parse geometries from shapely objects <code>root</code> <code>from_geopandas</code> Create <code>GeoDataFrame</code> or <code>GeoSeries</code> from Geopandas equivalent. <code>root</code> Serialization <code>to_wkt</code> Serialize each geometry as WKT (Well-Known Text). <code>root</code>, <code>Expr</code>, <code>Series</code>, <code>DataFrame</code> <code>to_ewkt</code> Serialize each geometry as EWKT (Extended Well-Known Text). <code>root</code>, <code>Expr</code>, <code>Series</code>, <code>DataFrame</code> <code>to_wkb</code> Serialize each geometry as WKB (Well-Known Binary). <code>root</code>, <code>Expr</code>, <code>Series</code>, <code>DataFrame</code> <code>to_geojson</code> Serialize each geometry as GeoJSON. <code>root</code>, <code>Expr</code>, <code>Series</code>, <code>DataFrame</code> <code>to_dict</code> Convert each geometry to a GeoJSON-like  Python <code>dict</code> object. <code>root</code>, <code>Expr</code>, <code>Series</code>, <code>DataFrame</code> <code>to_shapely</code> Convert each geometry to a Shapely object. <code>root</code>, <code>Expr</code>, <code>Series</code>, <code>DataFrame</code> <code>to_geopandas</code> Convert DataFrame or Series to GeoPandas equivalent. <code>Series</code>, <code>DataFrame</code> <code>__geo_interface__</code> Return a <code>dict</code> representation of a <code>GeometryCollection</code> or <code>FeatureCollection</code> <code>Series</code>, <code>DataFrame</code> General operations <code>geometry_type</code> Return the type ID of each geometry.. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>dimensions</code> Return the inherent dimensionality of each geometry.. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>coordinate_dimension</code> Return the coordinate dimension of each geometry.. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>area</code> Return the area of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>bounds</code> Return the bounds of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>length</code> Return the length of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>minimum_clearance</code> Return the minimum clearance of each geometry.. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>x</code> Return the <code>x</code> value of Point geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>y</code> Return the <code>y</code> value of Point geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>z</code> Return the <code>z</code> value of Point geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>m</code> Return the <code>m</code> value of Point geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>count_coordinates</code> Return the number of coordinates in each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>coordinates</code> Return the coordinates of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>count_geometries</code> Return the number of parts in multipart geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>get_geometry</code> Return the nth part of multipart geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>count_points</code> Return the number of points in LineString geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>get_point</code> Return the nth point of LineString geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>count_interior_rings</code> Return the number of interior rings in Polygon geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>get_interior_ring</code> Return the nth ring of Polygon geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>exterior_ring</code> Return the exterior ring of Polygon geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>rings</code> Return a list of rings for Polygon geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>parts</code> Return a list of parts for multipart geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>precision</code> Return the precision of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>set_precision</code> Set the precision of each geometry to a certain grid size. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>distance</code> Return the distance of each geometry to other. <code>Expr</code>, <code>Series</code> <code>hausdorff_distance</code> Return the geometries hausdorff distance to other geometries. <code>Expr</code>, <code>Series</code> <code>frechet_distance</code> Return the geometries frechet distance to other geometries. <code>Expr</code>, <code>Series</code> Projection operations <code>srid</code> Return the SRID of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>set_srid</code> Set the SRID of each geometry to a given value. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>to_srid</code> Transform the coordinates of each into a new CRS. <code>root</code>, <code>Expr</code>, <code>Series</code> Unary predicates <code>has_z</code> Return <code>True</code> for geometries that has <code>z</code> coordinate values. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>has_m</code> Return <code>True</code> for geometries that has <code>m</code> coordinate values. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>is_ccw</code> Return <code>True</code> for linear geometries with counter-clockwise coord sequence. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>is_closed</code> Return <code>True</code> for closed linear geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>is_empty</code> Return <code>True</code> for empty geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>is_ring</code> Return <code>True</code> for ring geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>is_simple</code> Return <code>True</code> for simple geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>is_valid</code> Return <code>True</code> for valid geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>is_valid_reason</code> Return an explanation string for the invalidity of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> Binary predicates <code>crosses</code> Return <code>True</code> when each geometry crosses other. <code>Expr</code>, <code>Series</code> <code>contains</code> Return <code>True</code> when each geometry contains other. <code>Expr</code>, <code>Series</code> <code>contains_properly</code> Return <code>True</code> when each geometry properly crosses other. <code>Expr</code>, <code>Series</code> <code>covered_by</code> Return <code>True</code> when each geometry is covered by other. <code>Expr</code>, <code>Series</code> <code>covers</code> Return <code>True</code> when each geometry covers other. <code>Expr</code>, <code>Series</code> <code>disjoint</code> Return <code>True</code> when each geometry is disjoint from other. <code>Expr</code>, <code>Series</code> <code>dwithin</code> Return <code>True</code> when each geometry is within given distance to other. <code>Expr</code>, <code>Series</code> <code>intersects</code> Return <code>True</code> when each geometry intersects other. <code>Expr</code>, <code>Series</code> <code>overlaps</code> Return <code>True</code> when each geometry overlaps other. <code>Expr</code>, <code>Series</code> <code>touches</code> Return <code>True</code> when each geometry touches other. <code>Expr</code>, <code>Series</code> <code>within</code> Return <code>True</code> when each geometry is within other. <code>Expr</code>, <code>Series</code> <code>equals</code> Return <code>True</code> when each geometry is equal to other. <code>Expr</code>, <code>Series</code> <code>equals_exact</code> Return <code>True</code> when each geometry is equal to other. <code>Expr</code>, <code>Series</code> <code>equals_identical</code> Return <code>True</code> when each geometry is equal to other. <code>Expr</code>, <code>Series</code> <code>relate</code> Return the DE-9IM intersection matrix of each geometry with other. <code>Expr</code>, <code>Series</code> <code>relate_pattern</code> Return <code>True</code> when the DE-9IM intersection matrix matches a given pattern. <code>Expr</code>, <code>Series</code> Set operations <code>union</code> Return the union of each geometry with other. <code>Expr</code>, <code>Series</code> <code>unary_union</code> Return the unary union of each geometry. <code>Expr</code>, <code>Series</code> <code>coverage_union</code> Return the coverage union of each geometry with other. <code>Expr</code>, <code>Series</code> <code>intersection</code> Return the intersection of each geometry with other. <code>Expr</code>, <code>Series</code> <code>difference</code> Return the difference of each geometry with other. <code>Expr</code>, <code>Series</code> <code>symmetric_difference</code> Return the symmetric difference of each geometry with other. <code>Expr</code>, <code>Series</code> Constructive operations <code>boundary</code> Return the topological boundary of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>buffer</code> Return a buffer around each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>offset_curve</code> Return a line at a given distance of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>centroid</code> Return the centroid of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>center</code> Return the center of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>clip_by_rect</code> Clips each geometry by a bounding rectangle. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>convex_hull</code> Return the convex hull of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>concave_hull</code> Return the concave hull of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>segmentize</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>envelope</code> Return the envelope of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>extract_unique_points</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>build_area</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>make_valid</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>normalize</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>node</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>point_on_surface</code> Return a point that intersects each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>remove_repeated_points</code> Remove the repeated points for each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>reverse</code> Reverse the coordinates order of each geometry. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>simplify</code> Simplify each geometry with a given tolerance. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>minimum_rotated_rectangle</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>snap</code> <code>Expr</code>, <code>Series</code> <code>shortest_line</code> Return the shortest line between each geometry and other. <code>Expr</code>, <code>Series</code> <code>sjoin</code> Perform a spatial join operation with another DataFrame. <code>DataFrame</code>, <code>LazyFrame</code> Affine transforms <code>affine_transform</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>translate</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>rotate</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>scale</code> <code>root</code>, <code>Expr</code>, <code>Series</code> LineString operations <code>interpolate</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>line_merge</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>shared_paths</code> <code>Expr</code>, <code>Series</code> Aggregation <code>total_bounds</code> Return the total bounds of all geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>multipoint</code> Aggregate Point geometries into a single MultiPoint. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>multilinestring</code> Aggregate LineString geometries into a single MultiLineString. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>multipolygon</code> Aggregate Polygon geometries into a single MultiPolygon. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>geometrycollection</code> Aggregate geometries into a single GeometryCollection. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>collect</code> Aggregate geometries into a single MultiPart geometry or GeometryCollection. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>union_all</code> Return the union of all geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>coverage_union_all</code> Return the coverage union of all geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>intersection_all</code> Return the intersection of all geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>difference_all</code> Return the difference of all geometries <code>root</code>, <code>Expr</code>, <code>Series</code> <code>symmetric_difference_all</code> Return the symmetric difference of all geometries. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>polygonize</code> <code>root</code>, <code>Expr</code>, <code>Series</code> <code>voronoi_polygons</code> Return a Voronoi diagram of all geometries vertices. <code>root</code>, <code>Expr</code>, <code>Series</code> <code>delaunay_triangles</code> Return a Delaunay triangulation of all geometries vertices. <code>root</code>, <code>Expr</code>, <code>Series</code> Plotting <code>plot</code> Create a map plot of a GeoSeries or GeoDataFrame. <code>Series</code>, <code>DataFrame</code>"},{"location":"api-reference/columns/","title":"Column Selection","text":""},{"location":"api-reference/columns/#polars_st.geom","title":"polars_st.geom","text":"<pre><code>geom(name: str | Iterable[str] | None = None, *more_names: str) -&gt; GeoExpr\n</code></pre> <p>Create a geometry column expression.</p> <p>Alias for     <code>polars.col</code>.     If no name is given, the default from <code>st.Config</code> will be used.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | Iterable[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The name or datatype of the geometry column(s) to represent. Accepts regular expression input. Regular expressions should start with <code>^</code> and end with <code>$</code>.</p> </li> <li> <code>more_names</code>               (<code>str</code>, default:                   <code>()</code> )           \u2013            <p>Additional names or datatypes of columns to represent, specified as positional arguments.</p> </li> </ul> <p>Examples:</p> <p>Pass a single column name to represent that column:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoSeries(\"my_geom\", [\"POINT(0 0)\"]).to_frame()\n&gt;&gt;&gt; gdf.select(st.geom(\"my_geom\").st.to_wkt())\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 my_geom     \u2502\n\u2502 ---         \u2502\n\u2502 str         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 POINT (0 0) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Call <code>geom</code> without a column name to use the default:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame([\n...     \"POINT(0 0)\",\n...     \"POINT(1 2)\",\n... ])\n&gt;&gt;&gt; gdf.select(st.geom().st.union_all().st.to_wkt())\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 geometry                  \u2502\n\u2502 ---                       \u2502\n\u2502 str                       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 MULTIPOINT ((0 0), (1 2)) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/columns/#polars_st.element","title":"polars_st.element","text":"<pre><code>element() -&gt; GeoExpr\n</code></pre> <p>Alias for <code>polars.element</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame([\n...     \"MULTIPOINT ((0 0), (1 2))\"\n... ])\n&gt;&gt;&gt; gdf.select(st.parts().list.eval(st.element().st.to_wkt()))\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 geometry                       \u2502\n\u2502 ---                            \u2502\n\u2502 list[str]                      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [\"POINT (0 0)\", \"POINT (1 2)\"] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/config/","title":"Configuration","text":""},{"location":"api-reference/config/#polars_st.Config","title":"polars_st.Config","text":"<pre><code>Config(geometry_column: str | None = None)\n</code></pre> <p>               Bases: <code>ContextDecorator</code></p> <p>Configuration object for <code>polars-st</code>.</p> <p>Parameters:</p> <ul> <li> <code>geometry_column</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Default geometry column name. Using <code>None</code> will reset this value to the built-in default <code>\"geometry\"</code>.</p> </li> </ul> <p>Examples:</p> <p>Use as a context manager:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoSeries(\"my_geometry\", [\"POINT(1 2)\"]).to_frame()\n&gt;&gt;&gt; with st.Config(geometry_column=\"my_geometry\"):\n...     x = gdf.select(st.x())\n&gt;&gt;&gt; x.schema\nSchema({'my_geometry': Float64})\n</code></pre> <p>Use as a context decorator:</p> <pre><code>&gt;&gt;&gt; @st.Config(geometry_column=\"my_geometry\")\n... def get_my_bounds(gdf):\n...     return gdf.select(st.bounds())\n&gt;&gt;&gt; gdf = st.GeoSeries(\"my_geometry\", [\"POINT(1 2)\"]).to_frame()\n&gt;&gt;&gt; bounds = get_my_bounds(gdf)\n&gt;&gt;&gt; bounds.schema\nSchema({'my_geometry': Array(Float64, shape=(4,))})\n</code></pre> <p>Use as a global configuration object:</p> <pre><code>&gt;&gt;&gt; st.Config.set_geometry_column(\"my_geometry\")\n&lt;class 'polars_st.config.Config'&gt;\n&gt;&gt;&gt; gdf = st.GeoSeries([\"POINT(1 2)\"]).to_frame()\n&gt;&gt;&gt; gdf.schema\nSchema({'my_geometry': Binary})\n</code></pre>"},{"location":"api-reference/config/#polars_st.Config.set_geometry_column","title":"set_geometry_column  <code>classmethod</code>","text":"<pre><code>set_geometry_column(name: str | None = None) -&gt; type[Self]\n</code></pre>"},{"location":"api-reference/config/#polars_st.Config.get_geometry_column","title":"get_geometry_column  <code>classmethod</code>","text":"<pre><code>get_geometry_column() -&gt; str\n</code></pre>"},{"location":"api-reference/geodataframe/","title":"GeoDataFrame","text":""},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrame","title":"polars_st.GeoDataFrame","text":"<pre><code>GeoDataFrame(\n    data: FrameInitTypes | None = None,\n    schema: SchemaDefinition | None = None,\n    *,\n    schema_overrides: SchemaDict | None = None,\n    strict: bool = True,\n    orient: Orientation | None = None,\n    infer_schema_length: int | None = N_INFER_DEFAULT,\n    nan_to_null: bool = False\n)\n</code></pre> <p>               Bases: <code>DataFrame</code></p> <p>Create a new GeoDataFrame.</p> <p>A GeoDataFrame is a regular <code>polars.DataFrame</code> with type annotations added for the <code>st</code> namespace.</p> <p>If a GeoDataFrame is created with a column matching the <code>Configuration</code>     default geometry column name, that column will be parsed into a GeoSeries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame({\n...     \"geometry\": [\n...         \"POINT(0 0)\",\n...         \"POINT(1 2)\",\n...     ]\n... })\n&gt;&gt;&gt; gdf.schema\nSchema({'geometry': Binary})\n</code></pre> <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame([\n...     \"POINT(0 0)\",\n...     \"POINT(1 2)\",\n... ])\n&gt;&gt;&gt; gdf.schema\nSchema({'geometry': Binary})\n</code></pre>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrame.st","title":"st  <code>property</code>","text":"<pre><code>st: GeoDataFrameNameSpace\n</code></pre>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace","title":"polars_st.GeoDataFrameNameSpace","text":""},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.__geo_interface__","title":"polars_st.GeoDataFrameNameSpace.__geo_interface__  <code>property</code>","text":"<pre><code>__geo_interface__: dict\n</code></pre> <p>Return a GeoJSON FeatureCollection <code>dict</code> representation of the DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame({\n...     \"geometry\": [\"POINT(0 0)\", \"POINT(1 2)\"],\n...     \"name\": [\"Alice\", \"Bob\"]\n... })\n&gt;&gt;&gt; interface = gdf.st.__geo_interface__\n&gt;&gt;&gt; pprint.pp(interface)\n{'type': 'FeatureCollection',\n 'features': [{'type': 'Feature',\n               'geometry': {'type': 'Point', 'coordinates': [0.0, 0.0]},\n               'properties': {'name': 'Alice'}},\n              {'type': 'Feature',\n               'geometry': {'type': 'Point', 'coordinates': [1.0, 2.0]},\n               'properties': {'name': 'Bob'}}]}\n</code></pre>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.sjoin","title":"polars_st.GeoDataFrameNameSpace.sjoin","text":"<pre><code>sjoin(\n    other: DataFrame,\n    on: str | Expr | None = None,\n    how: JoinStrategy = \"inner\",\n    predicate: Literal[\n        \"intersects_bbox\",\n        \"intersects\",\n        \"within\",\n        \"contains\",\n        \"overlaps\",\n        \"crosses\",\n        \"touches\",\n        \"covers\",\n        \"covered_by\",\n        \"contains_properly\",\n    ] = \"intersects\",\n    *,\n    left_on: str | Expr | None = None,\n    right_on: str | Expr | None = None,\n    suffix: str = \"_right\",\n    validate: JoinValidation = \"m:m\",\n    coalesce: bool | None = None\n) -&gt; GeoDataFrame\n</code></pre> <p>Perform a spatial join operation with another DataFrame.</p>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.to_wkt","title":"polars_st.GeoDataFrameNameSpace.to_wkt","text":"<pre><code>to_wkt(\n    rounding_precision: int | None = 6,\n    trim: bool = True,\n    output_dimension: Literal[2, 3, 4] = 3,\n    old_3d: bool = False,\n) -&gt; DataFrame\n</code></pre> <p>Serialize the DataFrame geometry column as WKT.</p> <p>See <code>GeoExprNameSpace.to_wkt</code>.</p>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.to_ewkt","title":"polars_st.GeoDataFrameNameSpace.to_ewkt","text":"<pre><code>to_ewkt(\n    rounding_precision: int | None = 6,\n    trim: bool = True,\n    output_dimension: Literal[2, 3, 4] = 3,\n    old_3d: bool = False,\n) -&gt; DataFrame\n</code></pre> <p>Serialize the DataFrame geometry column as EWKT.</p> <p>See <code>GeoExprNameSpace.to_ewkt</code>.</p>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.to_wkb","title":"polars_st.GeoDataFrameNameSpace.to_wkb","text":"<pre><code>to_wkb(\n    output_dimension: Literal[2, 3, 4] = 3,\n    byte_order: Literal[0, 1] | None = None,\n    include_srid: bool = False,\n) -&gt; DataFrame\n</code></pre> <p>Serialize the DataFrame geometry column as WKB.</p> <p>See <code>GeoExprNameSpace.to_wkb</code>.</p>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.to_geojson","title":"polars_st.GeoDataFrameNameSpace.to_geojson","text":"<pre><code>to_geojson(indent: int | None = None) -&gt; DataFrame\n</code></pre> <p>Serialize the DataFrame geometry column as GeoJSON.</p> <p>See <code>GeoExprNameSpace.to_geojson</code>.</p>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.to_shapely","title":"polars_st.GeoDataFrameNameSpace.to_shapely","text":"<pre><code>to_shapely() -&gt; DataFrame\n</code></pre> <p>Convert the DataFrame geometry column to a shapely representation.</p> <p>See <code>GeoExprNameSpace.to_shapely</code>.</p>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.to_dict","title":"polars_st.GeoDataFrameNameSpace.to_dict","text":"<pre><code>to_dict() -&gt; DataFrame\n</code></pre> <p>Convert the DataFrame geometry column to a GeoJSON-like Python <code>dict</code> representation.</p> <p>See <code>GeoExprNameSpace.to_dict</code>.</p>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.to_dicts","title":"polars_st.GeoDataFrameNameSpace.to_dicts","text":"<pre><code>to_dicts() -&gt; list[dict[str, Any]]\n</code></pre> <p>Convert every row to a Python dictionary representation of a GeoJSON Feature.</p>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.to_geopandas","title":"polars_st.GeoDataFrameNameSpace.to_geopandas","text":"<pre><code>to_geopandas(\n    *, use_pyarrow_extension_array: bool = False, **kwargs: Any\n) -&gt; GeoDataFrame\n</code></pre> <p>Convert this DataFrame to a geopandas GeoDataFrame.</p>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.write_file","title":"polars_st.GeoDataFrameNameSpace.write_file","text":"<pre><code>write_file(\n    path: str | BytesIO,\n    layer: str | None = None,\n    driver: str | None = None,\n    geometry_type: (\n        Literal[\n            \"Unknown\",\n            \"Point\",\n            \"LineString\",\n            \"Polygon\",\n            \"MultiPoint\",\n            \"MultiLineString\",\n            \"MultiPolygon\",\n            \"GeometryCollection\",\n        ]\n        | None\n    ) = None,\n    crs: str | None = None,\n    encoding: str | None = None,\n    append: bool = False,\n    dataset_metadata: dict | None = None,\n    layer_metadata: dict | None = None,\n    metadata: dict | None = None,\n    dataset_options: dict | None = None,\n    layer_options: dict | None = None,\n    **kwargs: dict[str, Any]\n) -&gt; None\n</code></pre> <p>Write the GeoDataFrame to an OGR supported file format.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | BytesIO</code>)           \u2013            <p>path to output file on writeable file system or an io.BytesIO object to allow writing to memory NOTE: support for writing to memory is limited to specific drivers.</p> </li> <li> <code>layer</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>layer name to create.  If writing to memory and layer name is not provided, it layer name will be set to a UUID4 value.</p> </li> <li> <code>driver</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The OGR format driver used to write the vector file. By default attempts to infer driver from path.  Must be provided to write to memory.</p> </li> <li> <code>geometry_type</code>               (<code>Literal['Unknown', 'Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'] | None</code>, default:                   <code>None</code> )           \u2013            <p>The geometry type of the written layer. Currently, this needs to be specified explicitly when creating a new layer with geometries.</p> <p>This parameter does not modify the geometry, but it will try to force the layer type of the output file to this value. Use this parameter with caution because using a wrong layer geometry type may result in errors when writing the file, may be ignored by the driver, or may result in invalid files.</p> </li> <li> <code>crs</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>WKT-encoded CRS of the geometries to be written.</p> </li> <li> <code>encoding</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Only used for the .dbf file of ESRI Shapefiles. If not specified, uses the default locale.</p> </li> <li> <code>append</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the data source specified by path already exists, and the driver supports appending to an existing data source, will cause the data to be appended to the existing records in the data source.  Not supported for writing to in-memory files. NOTE: append support is limited to specific drivers and GDAL versions.</p> </li> <li> <code>dataset_metadata</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Metadata to be stored at the dataset level in the output file; limited to drivers that support writing metadata, such as GPKG, and silently ignored otherwise. Keys and values must be strings.</p> </li> <li> <code>layer_metadata</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Metadata to be stored at the layer level in the output file; limited to drivers that support writing metadata, such as GPKG, and silently ignored otherwise. Keys and values must be strings.</p> </li> <li> <code>metadata</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>alias of layer_metadata</p> </li> <li> <code>dataset_options</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Dataset creation options (format specific) passed to OGR. Specify as a key-value dictionary.</p> </li> <li> <code>layer_options</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Layer creation options (format specific) passed to OGR. Specify as a key-value dictionary.</p> </li> <li> <code>**kwargs</code>               (<code>dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional driver-specific dataset or layer creation options passed to OGR. pyogrio will attempt to automatically pass those keywords either as dataset or as layer creation option based on the known options for the specific driver. Alternatively, you can use the explicit <code>dataset_options</code> or <code>layer_options</code> keywords to manually do this (for example if an option exists as both dataset and layer option).</p> </li> </ul>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.write_geojson","title":"polars_st.GeoDataFrameNameSpace.write_geojson","text":"<pre><code>write_geojson(file: IOBase | str | Path | None = None) -&gt; str | None\n</code></pre> <p>Serialize to GeoJSON FeatureCollection representation.</p> <p>The result will be invalid if the geometry column contains different geometry types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame({\n...     \"geometry\": [\"POINT(0 0)\", \"POINT(1 2)\"],\n...     \"name\": [\"Alice\", \"Bob\"]\n... })\n&gt;&gt;&gt; geojson = gdf.st.write_geojson()\n&gt;&gt;&gt; print(geojson)\n{\"type\":\"FeatureCollection\",\"features\":[{\"properties\":{\"name\":\"Alice\"},\"geometry\":{\"type\":\"Point\",\"coordinates\":[0.0,0.0]}},{\"properties\":{\"name\":\"Bob\"},\"geometry\":{\"type\":\"Point\",\"coordinates\":[1.0,2.0]}}]}\n</code></pre>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.write_geojsonseq","title":"polars_st.GeoDataFrameNameSpace.write_geojsonseq","text":"<pre><code>write_geojsonseq(file: IOBase | str | Path | None = None) -&gt; str | None\n</code></pre> <p>Serialize to newline delimited GeoJSON representation.</p> <p>The result will be invalid if the geometry column contains different geometry types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame({\n...     \"geometry\": [\"POINT(0 0)\", \"POINT(1 2)\"],\n...     \"name\": [\"Alice\", \"Bob\"]\n... })\n&gt;&gt;&gt; geojsonseq = gdf.st.write_geojsonseq()\n&gt;&gt;&gt; print(geojsonseq)\n{\"properties\":{\"name\":\"Alice\"},\"geometry\":{\"type\":\"Point\",\"coordinates\":[0.0,0.0]}}\n{\"properties\":{\"name\":\"Bob\"},\"geometry\":{\"type\":\"Point\",\"coordinates\":[1.0,2.0]}}\n</code></pre>"},{"location":"api-reference/geodataframe/#polars_st.GeoDataFrameNameSpace.plot","title":"polars_st.GeoDataFrameNameSpace.plot","text":"<pre><code>plot(**kwargs: Unpack[EncodeKwds]) -&gt; Chart\n</code></pre> <p>Draw map plot.</p> <p>Polars does not implement plotting logic itself but instead defers to <code>Altair</code>.</p> <p><code>df.st.plot(**kwargs)</code> is shorthand for <code>alt.Chart(df).mark_geoshape().encode(**kwargs).interactive()</code>. Please read Altair GeoShape documentation for available options.</p>"},{"location":"api-reference/geoexpr/","title":"GeoExpr","text":""},{"location":"api-reference/geoexpr/#polars_st.GeoExpr","title":"polars_st.GeoExpr","text":"<p>               Bases: <code>Expr</code></p> <p>A <code>GeoExpr</code> is a regular <code>polars.Expr</code> with type annotations added for the <code>st</code> namespace.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExpr.st","title":"st  <code>property</code>","text":"<pre><code>st: GeoExprNameSpace\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace","title":"polars_st.GeoExprNameSpace","text":""},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.geometry_type","title":"polars_st.GeoExprNameSpace.geometry_type","text":"<pre><code>geometry_type() -&gt; Expr\n</code></pre> <p>Return the type ID of each geometry.</p> <ul> <li>0 = Unknown</li> <li>1 = Point</li> <li>2 = LineString</li> <li>3 = Polygon</li> <li>4 = MultiPoint</li> <li>5 = MultiLineString</li> <li>6 = MultiPolygon</li> <li>7 = GeometryCollection</li> <li>8 = CircularString</li> <li>9 = CompoundCurve</li> <li>10 = CurvePolygon</li> <li>11 = MultiCurve</li> <li>12 = MultiSurface</li> <li>13 = Curve</li> <li>14 = Surface</li> <li>15 = PolyhedralSurface</li> <li>16 = Tin</li> <li>17 = Triangle</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame([\n...     \"POINT(0 0)\",\n...     \"LINESTRING(0 0, 1 2)\",\n...     \"POLYGON((0 0, 1 1, 1 0, 0 0))\"\n... ])\n&gt;&gt;&gt; gdf.select(st.geom().st.geometry_type())\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 geometry \u2502\n\u2502 ---      \u2502\n\u2502 u32      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1        \u2502\n\u2502 2        \u2502\n\u2502 3        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.dimensions","title":"polars_st.GeoExprNameSpace.dimensions","text":"<pre><code>dimensions() -&gt; Expr\n</code></pre> <p>Return the inherent dimensionality of each geometry.</p> <p>The inherent dimension is 0 for points, 1 for linestrings and linearrings,     and 2 for polygons. For geometrycollections it is the max of the containing     elements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gdf = st.GeoDataFrame([\n...     \"POINT(0 0)\",\n...     \"LINESTRING(0 0, 1 2)\",\n...     \"POLYGON((0 0, 1 1, 1 0, 0 0))\"\n... ])\n&gt;&gt;&gt; gdf.select(st.geom().st.dimensions())\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 geometry \u2502\n\u2502 ---      \u2502\n\u2502 i32      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0        \u2502\n\u2502 1        \u2502\n\u2502 2        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.coordinate_dimension","title":"polars_st.GeoExprNameSpace.coordinate_dimension","text":"<pre><code>coordinate_dimension() -&gt; Expr\n</code></pre> <p>Return the coordinate dimension (2, 3 or 4) of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.area","title":"polars_st.GeoExprNameSpace.area","text":"<pre><code>area() -&gt; Expr\n</code></pre> <p>Return the area of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.bounds","title":"polars_st.GeoExprNameSpace.bounds","text":"<pre><code>bounds() -&gt; Expr\n</code></pre> <p>Return the bounds of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.length","title":"polars_st.GeoExprNameSpace.length","text":"<pre><code>length() -&gt; Expr\n</code></pre> <p>Return the length of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.minimum_clearance","title":"polars_st.GeoExprNameSpace.minimum_clearance","text":"<pre><code>minimum_clearance() -&gt; Expr\n</code></pre> <p>Return the geometry minimum clearance.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.x","title":"polars_st.GeoExprNameSpace.x","text":"<pre><code>x() -&gt; Expr\n</code></pre> <p>Return the <code>x</code> value of Point geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.y","title":"polars_st.GeoExprNameSpace.y","text":"<pre><code>y() -&gt; Expr\n</code></pre> <p>Return the <code>y</code> value of Point geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.z","title":"polars_st.GeoExprNameSpace.z","text":"<pre><code>z() -&gt; Expr\n</code></pre> <p>Return the <code>z</code> value of Point geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.m","title":"polars_st.GeoExprNameSpace.m","text":"<pre><code>m() -&gt; Expr\n</code></pre> <p>Return the <code>m</code> value of Point geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.count_coordinates","title":"polars_st.GeoExprNameSpace.count_coordinates","text":"<pre><code>count_coordinates() -&gt; Expr\n</code></pre> <p>Return the number of coordinates in each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.coordinates","title":"polars_st.GeoExprNameSpace.coordinates","text":"<pre><code>coordinates(output_dimension: Literal[2, 3] = 2) -&gt; Expr\n</code></pre> <p>Return the coordinates of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.count_geometries","title":"polars_st.GeoExprNameSpace.count_geometries","text":"<pre><code>count_geometries() -&gt; Expr\n</code></pre> <p>Return the number of parts in multipart geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.get_geometry","title":"polars_st.GeoExprNameSpace.get_geometry","text":"<pre><code>get_geometry(index: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>Return the nth part of multipart geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.count_points","title":"polars_st.GeoExprNameSpace.count_points","text":"<pre><code>count_points() -&gt; Expr\n</code></pre> <p>Return the number of points in LineString geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.get_point","title":"polars_st.GeoExprNameSpace.get_point","text":"<pre><code>get_point(index: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>Return the nth point of LineString geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.count_interior_rings","title":"polars_st.GeoExprNameSpace.count_interior_rings","text":"<pre><code>count_interior_rings() -&gt; Expr\n</code></pre> <p>Return the number of interior rings in Polygon geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.get_interior_ring","title":"polars_st.GeoExprNameSpace.get_interior_ring","text":"<pre><code>get_interior_ring(index: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>Return the nth ring of Polygon geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.exterior_ring","title":"polars_st.GeoExprNameSpace.exterior_ring","text":"<pre><code>exterior_ring() -&gt; GeoExpr\n</code></pre> <p>Return the exterior ring of Polygon geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.rings","title":"polars_st.GeoExprNameSpace.rings","text":"<pre><code>rings() -&gt; Expr\n</code></pre> <p>Return the list of rings for Polygon geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.parts","title":"polars_st.GeoExprNameSpace.parts","text":"<pre><code>parts() -&gt; Expr\n</code></pre> <p>Return the list of parts for multipart geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.precision","title":"polars_st.GeoExprNameSpace.precision","text":"<pre><code>precision() -&gt; Expr\n</code></pre> <p>Return the precision of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.set_precision","title":"polars_st.GeoExprNameSpace.set_precision","text":"<pre><code>set_precision(\n    grid_size: IntoDecimalExpr,\n    mode: Literal[\"valid_output\", \"no_topo\", \"keep_collapsed\"] = \"valid_output\",\n) -&gt; GeoExpr\n</code></pre> <p>Set the precision of each geometry to a certain grid size.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.distance","title":"polars_st.GeoExprNameSpace.distance","text":"<pre><code>distance(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return the distance from each geometry to other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.hausdorff_distance","title":"polars_st.GeoExprNameSpace.hausdorff_distance","text":"<pre><code>hausdorff_distance(\n    other: IntoGeoExprColumn, densify: float | None = None\n) -&gt; Expr\n</code></pre> <p>Return the hausdorff distance from each geometry to other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.frechet_distance","title":"polars_st.GeoExprNameSpace.frechet_distance","text":"<pre><code>frechet_distance(\n    other: IntoGeoExprColumn, densify: float | None = None\n) -&gt; Expr\n</code></pre> <p>Return the frechet distance from each geometry to other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.srid","title":"polars_st.GeoExprNameSpace.srid","text":"<pre><code>srid() -&gt; Expr\n</code></pre> <p>Return the geometry SRID.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.set_srid","title":"polars_st.GeoExprNameSpace.set_srid","text":"<pre><code>set_srid(srid: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>Set the SRID of each geometry to a given value.</p> <p>Parameters:</p> <ul> <li> <code>srid</code>               (<code>IntoIntegerExpr</code>)           \u2013            <p>The geometry new SRID</p> </li> </ul>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.to_srid","title":"polars_st.GeoExprNameSpace.to_srid","text":"<pre><code>to_srid(srid: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>Transform the coordinates of each geometry into a new CRS.</p> <p>Parameters:</p> <ul> <li> <code>srid</code>               (<code>IntoIntegerExpr</code>)           \u2013            <p>The geometry new SRID</p> </li> </ul>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.to_wkt","title":"polars_st.GeoExprNameSpace.to_wkt","text":"<pre><code>to_wkt(\n    rounding_precision: int | None = 6,\n    trim: bool = True,\n    output_dimension: Literal[2, 3, 4] = 3,\n    old_3d: bool = False,\n) -&gt; Expr\n</code></pre> <p>Serialize each geometry as WKT (Well-Known Text).</p> <p>Parameters:</p> <ul> <li> <code>rounding_precision</code>               (<code>int | None</code>, default:                   <code>6</code> )           \u2013            <p>The rounding precision when writing the WKT string. Set to None to indicate the full precision.</p> </li> <li> <code>trim</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, trim unnecessary decimals (trailing zeros).</p> </li> <li> <code>output_dimension</code>               (<code>Literal[2, 3, 4]</code>, default:                   <code>3</code> )           \u2013            <p>The output dimension for the WKT string. Specifying 3 means that up to 3 dimensions will be written but 2D geometries will still be represented as 2D in the WKT string.</p> </li> <li> <code>old_3d</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Enable old style 3D/4D WKT generation. By default, new style 3D/4D WKT (ie. \u201cPOINT Z (10 20 30)\u201d) is returned, but with <code>old_3d=True</code> the WKT will be formatted in the style \u201cPOINT (10 20 30)\u201d.</p> </li> </ul>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.to_ewkt","title":"polars_st.GeoExprNameSpace.to_ewkt","text":"<pre><code>to_ewkt(\n    rounding_precision: int | None = 6,\n    trim: bool = True,\n    output_dimension: Literal[2, 3, 4] = 3,\n    old_3d: bool = False,\n) -&gt; Expr\n</code></pre> <p>Serialize each geometry as EWKT (Extended Well-Known Text).</p> <p>Parameters:</p> <ul> <li> <code>rounding_precision</code>               (<code>int | None</code>, default:                   <code>6</code> )           \u2013            <p>The rounding precision when writing the WKT string. Set to None to indicate the full precision.</p> </li> <li> <code>trim</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, trim unnecessary decimals (trailing zeros).</p> </li> <li> <code>output_dimension</code>               (<code>Literal[2, 3, 4]</code>, default:                   <code>3</code> )           \u2013            <p>The output dimension for the WKT string. Specifying 3 means that up to 3 dimensions will be written but 2D geometries will still be represented as 2D in the WKT string.</p> </li> <li> <code>old_3d</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Enable old style 3D/4D WKT generation. By default, new style 3D/4D WKT (ie. \u201cPOINT Z (10 20 30)\u201d) is returned, but with <code>old_3d=True</code> the WKT will be formatted in the style \u201cPOINT (10 20 30)\u201d.</p> </li> </ul>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.to_wkb","title":"polars_st.GeoExprNameSpace.to_wkb","text":"<pre><code>to_wkb(\n    output_dimension: Literal[2, 3, 4] = 3,\n    byte_order: Literal[0, 1] | None = None,\n    include_srid: bool = False,\n) -&gt; Expr\n</code></pre> <p>Serialize each geometry as WKB (Well-Known Binary).</p> <p>Parameters:</p> <ul> <li> <code>output_dimension</code>           \u2013            <p>The output dimension for the WKB. Specifying 3 means that up to 3 dimensions will be written but 2D geometries will still be represented as 2D in the WKB representation.</p> </li> <li> <code>byte_order</code>               (<code>Literal[0, 1] | None</code>, default:                   <code>None</code> )           \u2013            <p>Defaults to native machine byte order (<code>None</code>). Use 0 to force big endian and 1 for little endian.</p> </li> <li> <code>include_srid</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the SRID is be included in WKB (this is an extension to the OGC WKB specification).</p> </li> </ul>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.to_geojson","title":"polars_st.GeoExprNameSpace.to_geojson","text":"<pre><code>to_geojson(indent: int | None = None) -&gt; Expr\n</code></pre> <p>Serialize each geometry as GeoJSON.</p> <p>Parameters:</p> <ul> <li> <code>indent</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>If indent is not <code>None</code>, then GeoJSON will be pretty-printed. An indent level of 0 will only insert newlines. <code>None</code> (the default) outputs the most compact representation.</p> </li> </ul>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.to_shapely","title":"polars_st.GeoExprNameSpace.to_shapely","text":"<pre><code>to_shapely() -&gt; Expr\n</code></pre> <p>Convert each geometry to a Shapely object.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.to_dict","title":"polars_st.GeoExprNameSpace.to_dict","text":"<pre><code>to_dict() -&gt; Expr\n</code></pre> <p>Convert each geometry to a GeoJSON-like Python <code>dict</code> object.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.has_z","title":"polars_st.GeoExprNameSpace.has_z","text":"<pre><code>has_z() -&gt; Expr\n</code></pre> <p>Return <code>True</code> for each geometry with <code>z</code> coordinate values.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.has_m","title":"polars_st.GeoExprNameSpace.has_m","text":"<pre><code>has_m() -&gt; Expr\n</code></pre> <p>Return <code>True</code> for each geometry with <code>m</code> coordinate values.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.is_ccw","title":"polars_st.GeoExprNameSpace.is_ccw","text":"<pre><code>is_ccw() -&gt; Expr\n</code></pre> <p>Return <code>True</code> for linear geometries with counter-clockwise coord sequence.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.is_closed","title":"polars_st.GeoExprNameSpace.is_closed","text":"<pre><code>is_closed() -&gt; Expr\n</code></pre> <p>Return <code>True</code> for closed linear geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.is_empty","title":"polars_st.GeoExprNameSpace.is_empty","text":"<pre><code>is_empty() -&gt; Expr\n</code></pre> <p>Return <code>True</code> for empty geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.is_ring","title":"polars_st.GeoExprNameSpace.is_ring","text":"<pre><code>is_ring() -&gt; Expr\n</code></pre> <p>Return <code>True</code> for ring geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.is_simple","title":"polars_st.GeoExprNameSpace.is_simple","text":"<pre><code>is_simple() -&gt; Expr\n</code></pre> <p>Return <code>True</code> for simple geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.is_valid","title":"polars_st.GeoExprNameSpace.is_valid","text":"<pre><code>is_valid() -&gt; Expr\n</code></pre> <p>Return <code>True</code> for valid geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.is_valid_reason","title":"polars_st.GeoExprNameSpace.is_valid_reason","text":"<pre><code>is_valid_reason() -&gt; Expr\n</code></pre> <p>Return an explanation string for the invalidity of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.crosses","title":"polars_st.GeoExprNameSpace.crosses","text":"<pre><code>crosses(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry crosses other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.contains","title":"polars_st.GeoExprNameSpace.contains","text":"<pre><code>contains(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry contains other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.contains_properly","title":"polars_st.GeoExprNameSpace.contains_properly","text":"<pre><code>contains_properly(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry properly contains other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.covered_by","title":"polars_st.GeoExprNameSpace.covered_by","text":"<pre><code>covered_by(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry is covered by other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.covers","title":"polars_st.GeoExprNameSpace.covers","text":"<pre><code>covers(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry covers other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.disjoint","title":"polars_st.GeoExprNameSpace.disjoint","text":"<pre><code>disjoint(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry is disjoint from other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.dwithin","title":"polars_st.GeoExprNameSpace.dwithin","text":"<pre><code>dwithin(other: IntoGeoExprColumn, distance: float) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry is within given distance to other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.intersects","title":"polars_st.GeoExprNameSpace.intersects","text":"<pre><code>intersects(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry intersects other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.overlaps","title":"polars_st.GeoExprNameSpace.overlaps","text":"<pre><code>overlaps(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry overlaps other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.touches","title":"polars_st.GeoExprNameSpace.touches","text":"<pre><code>touches(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry touches other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.within","title":"polars_st.GeoExprNameSpace.within","text":"<pre><code>within(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry is within other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.equals","title":"polars_st.GeoExprNameSpace.equals","text":"<pre><code>equals(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry is equal to other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.equals_exact","title":"polars_st.GeoExprNameSpace.equals_exact","text":"<pre><code>equals_exact(other: IntoGeoExprColumn, tolerance: float = 0.0) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry is equal to other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.equals_identical","title":"polars_st.GeoExprNameSpace.equals_identical","text":"<pre><code>equals_identical(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when each geometry is equal to other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.relate","title":"polars_st.GeoExprNameSpace.relate","text":"<pre><code>relate(other: IntoGeoExprColumn) -&gt; Expr\n</code></pre> <p>Return the DE-9IM intersection matrix of each geometry with other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.relate_pattern","title":"polars_st.GeoExprNameSpace.relate_pattern","text":"<pre><code>relate_pattern(other: IntoGeoExprColumn, pattern: str) -&gt; Expr\n</code></pre> <p>Return <code>True</code> when the DE-9IM intersection matrix of geometry with other matches a given pattern.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.union","title":"polars_st.GeoExprNameSpace.union","text":"<pre><code>union(other: IntoGeoExprColumn, grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>Return the union of each geometry with other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.unary_union","title":"polars_st.GeoExprNameSpace.unary_union","text":"<pre><code>unary_union(grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>Return the unary union of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.coverage_union","title":"polars_st.GeoExprNameSpace.coverage_union","text":"<pre><code>coverage_union() -&gt; GeoExpr\n</code></pre> <p>Return the coverage union of each geometry with other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.intersection","title":"polars_st.GeoExprNameSpace.intersection","text":"<pre><code>intersection(\n    other: IntoGeoExprColumn, grid_size: float | None = None\n) -&gt; GeoExpr\n</code></pre> <p>Return the intersection of each geometry with other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.difference","title":"polars_st.GeoExprNameSpace.difference","text":"<pre><code>difference(other: IntoGeoExprColumn, grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>Return the difference of each geometry with other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.symmetric_difference","title":"polars_st.GeoExprNameSpace.symmetric_difference","text":"<pre><code>symmetric_difference(\n    other: IntoGeoExprColumn, grid_size: float | None = None\n) -&gt; GeoExpr\n</code></pre> <p>Return the symmetric difference of each geometry with other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.boundary","title":"polars_st.GeoExprNameSpace.boundary","text":"<pre><code>boundary() -&gt; GeoExpr\n</code></pre> <p>Return the topological boundary of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.buffer","title":"polars_st.GeoExprNameSpace.buffer","text":"<pre><code>buffer(\n    distance: IntoDecimalExpr,\n    quad_segs: int = 8,\n    cap_style: Literal[\"round\", \"square\", \"flat\"] = \"round\",\n    join_style: Literal[\"round\", \"mitre\", \"bevel\"] = \"round\",\n    mitre_limit: float = 5.0,\n    single_sided: bool = False,\n) -&gt; GeoExpr\n</code></pre> <p>Return a buffer around each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.offset_curve","title":"polars_st.GeoExprNameSpace.offset_curve","text":"<pre><code>offset_curve(\n    distance: IntoDecimalExpr,\n    quad_segs: int = 8,\n    join_style: Literal[\"round\", \"mitre\", \"bevel\"] = \"round\",\n    mitre_limit: float = 5.0,\n) -&gt; GeoExpr\n</code></pre> <p>Return a line at a given distance of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.centroid","title":"polars_st.GeoExprNameSpace.centroid","text":"<pre><code>centroid() -&gt; GeoExpr\n</code></pre> <p>Return the centroid of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.center","title":"polars_st.GeoExprNameSpace.center","text":"<pre><code>center() -&gt; GeoExpr\n</code></pre> <p>Return the bounding box center of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.clip_by_rect","title":"polars_st.GeoExprNameSpace.clip_by_rect","text":"<pre><code>clip_by_rect(xmin: float, ymin: float, xmax: float, ymax: float) -&gt; GeoExpr\n</code></pre> <p>Clip each geometry by a bounding rectangle.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.convex_hull","title":"polars_st.GeoExprNameSpace.convex_hull","text":"<pre><code>convex_hull() -&gt; GeoExpr\n</code></pre> <p>Return the convex hull of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.concave_hull","title":"polars_st.GeoExprNameSpace.concave_hull","text":"<pre><code>concave_hull(ratio: float = 0.0, allow_holes: bool = False) -&gt; GeoExpr\n</code></pre> <p>Return the concave hull of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.segmentize","title":"polars_st.GeoExprNameSpace.segmentize","text":"<pre><code>segmentize(max_segment_length: IntoDecimalExpr) -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.envelope","title":"polars_st.GeoExprNameSpace.envelope","text":"<pre><code>envelope() -&gt; GeoExpr\n</code></pre> <p>Return the envelope of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.extract_unique_points","title":"polars_st.GeoExprNameSpace.extract_unique_points","text":"<pre><code>extract_unique_points() -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.build_area","title":"polars_st.GeoExprNameSpace.build_area","text":"<pre><code>build_area() -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.make_valid","title":"polars_st.GeoExprNameSpace.make_valid","text":"<pre><code>make_valid() -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.normalize","title":"polars_st.GeoExprNameSpace.normalize","text":"<pre><code>normalize() -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.node","title":"polars_st.GeoExprNameSpace.node","text":"<pre><code>node() -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.point_on_surface","title":"polars_st.GeoExprNameSpace.point_on_surface","text":"<pre><code>point_on_surface() -&gt; GeoExpr\n</code></pre> <p>Return a point that intersects of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.remove_repeated_points","title":"polars_st.GeoExprNameSpace.remove_repeated_points","text":"<pre><code>remove_repeated_points(tolerance: IntoDecimalExpr = 0.0) -&gt; GeoExpr\n</code></pre> <p>Remove the repeated points for each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.reverse","title":"polars_st.GeoExprNameSpace.reverse","text":"<pre><code>reverse() -&gt; GeoExpr\n</code></pre> <p>Reverse the coordinates order of each geometry.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.simplify","title":"polars_st.GeoExprNameSpace.simplify","text":"<pre><code>simplify(tolerance: IntoDecimalExpr, preserve_topology: bool = True) -&gt; GeoExpr\n</code></pre> <p>Simplify each geometry with a given tolerance.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.minimum_rotated_rectangle","title":"polars_st.GeoExprNameSpace.minimum_rotated_rectangle","text":"<pre><code>minimum_rotated_rectangle() -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.snap","title":"polars_st.GeoExprNameSpace.snap","text":"<pre><code>snap(other: IntoGeoExprColumn, tolerance: IntoDecimalExpr) -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.shortest_line","title":"polars_st.GeoExprNameSpace.shortest_line","text":"<pre><code>shortest_line(other: IntoGeoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Return the shortest line between each geometry and other.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.affine_transform","title":"polars_st.GeoExprNameSpace.affine_transform","text":"<pre><code>affine_transform(matrix: IntoExprColumn | Sequence[float]) -&gt; GeoExpr\n</code></pre> <p>Apply a 2D or 3D transformation matrix to the coordinates of each geometry.</p> <p>Parameters:</p> <ul> <li> <code>matrix</code>               (<code>IntoExprColumn | Sequence[float]</code>)           \u2013            <p>The transformation matrix to apply to coordinates. Should contains 6 elements for a 2D transform or 12 for a 3D transform. The matrix elements order should be: - <code>m11</code>, <code>m12</code>, <code>m21</code>, <code>m22</code>, <code>tx</code>, <code>ty</code> for 2D transformations - <code>m11</code>, <code>m12</code>, <code>m13</code>, <code>m21</code>, <code>m22</code>, <code>m23</code>, <code>m31</code>, <code>m32</code>, <code>m33</code>, <code>tx</code>, <code>ty</code>, <code>tz</code>     for 3D transformations</p> </li> </ul>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.translate","title":"polars_st.GeoExprNameSpace.translate","text":"<pre><code>translate(\n    x: IntoDecimalExpr = 0.0, y: IntoDecimalExpr = 0.0, z: IntoDecimalExpr = 0.0\n) -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.rotate","title":"polars_st.GeoExprNameSpace.rotate","text":"<pre><code>rotate(\n    angle: IntoDecimalExpr,\n    origin: (\n        Literal[\"center\", \"centroid\"] | Sequence[float] | Expr | Series\n    ) = \"center\",\n) -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.scale","title":"polars_st.GeoExprNameSpace.scale","text":"<pre><code>scale(\n    x: IntoDecimalExpr = 1.0,\n    y: IntoDecimalExpr = 1.0,\n    z: IntoDecimalExpr = 1.0,\n    origin: (\n        Literal[\"center\", \"centroid\"] | Sequence[float] | Expr | Series\n    ) = \"center\",\n) -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.interpolate","title":"polars_st.GeoExprNameSpace.interpolate","text":"<pre><code>interpolate(distance: IntoDecimalExpr, normalized: bool = False) -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.line_merge","title":"polars_st.GeoExprNameSpace.line_merge","text":"<pre><code>line_merge(directed: bool = False) -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.shared_paths","title":"polars_st.GeoExprNameSpace.shared_paths","text":"<pre><code>shared_paths(other: IntoGeoExprColumn) -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.total_bounds","title":"polars_st.GeoExprNameSpace.total_bounds","text":"<pre><code>total_bounds() -&gt; Expr\n</code></pre> <p>Return the total bounds of all geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.multipoint","title":"polars_st.GeoExprNameSpace.multipoint","text":"<pre><code>multipoint() -&gt; GeoExpr\n</code></pre> <p>Aggregate Point geometries into a single MultiPoint.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.multilinestring","title":"polars_st.GeoExprNameSpace.multilinestring","text":"<pre><code>multilinestring() -&gt; GeoExpr\n</code></pre> <p>Aggregate LineString geometries into a single MultiLineString.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.multipolygon","title":"polars_st.GeoExprNameSpace.multipolygon","text":"<pre><code>multipolygon() -&gt; GeoExpr\n</code></pre> <p>Aggregate Polygon geometries into a single MultiPolygon.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.geometrycollection","title":"polars_st.GeoExprNameSpace.geometrycollection","text":"<pre><code>geometrycollection() -&gt; GeoExpr\n</code></pre> <p>Aggregate geometries into a single GeometryCollection.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.collect","title":"polars_st.GeoExprNameSpace.collect","text":"<pre><code>collect() -&gt; GeoExpr\n</code></pre> <p>Aggregate geometries into a single MultiPart geometry or GeometryCollection.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.union_all","title":"polars_st.GeoExprNameSpace.union_all","text":"<pre><code>union_all(grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>Return the union of all geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.coverage_union_all","title":"polars_st.GeoExprNameSpace.coverage_union_all","text":"<pre><code>coverage_union_all() -&gt; GeoExpr\n</code></pre> <p>Return the coverage union of all geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.intersection_all","title":"polars_st.GeoExprNameSpace.intersection_all","text":"<pre><code>intersection_all(grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>Return the intersection of all geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.difference_all","title":"polars_st.GeoExprNameSpace.difference_all","text":"<pre><code>difference_all(grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>Return the difference of all geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.symmetric_difference_all","title":"polars_st.GeoExprNameSpace.symmetric_difference_all","text":"<pre><code>symmetric_difference_all(grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>Return the symmetric difference of all geometries.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.polygonize","title":"polars_st.GeoExprNameSpace.polygonize","text":"<pre><code>polygonize() -&gt; GeoExpr\n</code></pre>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.voronoi_polygons","title":"polars_st.GeoExprNameSpace.voronoi_polygons","text":"<pre><code>voronoi_polygons(\n    tolerance: float = 0.0,\n    extend_to: bytes | None = None,\n    only_edges: bool = False,\n) -&gt; GeoExpr\n</code></pre> <p>Return a Voronoi diagram of all geometries vertices.</p>"},{"location":"api-reference/geoexpr/#polars_st.GeoExprNameSpace.delaunay_triangles","title":"polars_st.GeoExprNameSpace.delaunay_triangles","text":"<pre><code>delaunay_triangles(tolerance: float = 0.0, only_edges: bool = False) -&gt; GeoExpr\n</code></pre> <p>Return a Delaunay triangulation of all geometries vertices.</p>"},{"location":"api-reference/geolazyframe/","title":"GeoLazyFrame","text":""},{"location":"api-reference/geolazyframe/#polars_st.GeoLazyFrame","title":"polars_st.GeoLazyFrame","text":"<p>               Bases: <code>LazyFrame</code></p>"},{"location":"api-reference/geolazyframe/#polars_st.GeoLazyFrame.st","title":"st  <code>property</code>","text":"<pre><code>st: GeoLazyFrameNameSpace\n</code></pre>"},{"location":"api-reference/geolazyframe/#polars_st.GeoLazyFrameNameSpace","title":"polars_st.GeoLazyFrameNameSpace","text":""},{"location":"api-reference/geolazyframe/#polars_st.GeoLazyFrameNameSpace.sjoin","title":"polars_st.GeoLazyFrameNameSpace.sjoin","text":"<pre><code>sjoin(\n    other: LazyFrame,\n    on: str | Expr | None = None,\n    how: JoinStrategy = \"inner\",\n    predicate: Literal[\n        \"intersects_bbox\",\n        \"intersects\",\n        \"within\",\n        \"contains\",\n        \"overlaps\",\n        \"crosses\",\n        \"touches\",\n        \"covers\",\n        \"covered_by\",\n        \"contains_properly\",\n    ] = \"intersects\",\n    *,\n    left_on: str | Expr | None = None,\n    right_on: str | Expr | None = None,\n    suffix: str = \"_right\",\n    validate: JoinValidation = \"m:m\",\n    join_nulls: bool = False,\n    coalesce: bool | None = None,\n    allow_parallel: bool = True,\n    force_parallel: bool = False\n) -&gt; LazyFrame\n</code></pre> <p>Perform a spatial join operation with another LazyFrame.</p>"},{"location":"api-reference/geoseries/","title":"GeoSeries","text":""},{"location":"api-reference/geoseries/#polars_st.GeoSeries","title":"polars_st.GeoSeries","text":"<pre><code>GeoSeries(\n    name: str | ArrayLike | None = None,\n    values: ArrayLike | None = None,\n    dtype: PolarsDataType | None = None,\n    *,\n    strict: bool = True,\n    nan_to_null: bool = False\n)\n</code></pre> <p>               Bases: <code>Series</code></p> <p>Create a new GeoSeries.</p> <p>A GeoSeries is a regular <code>polars.Series</code> with type annotations added for the <code>st</code> namespace. It contains geometries in binary EWKB format.</p> <p>You can create a GeoSeries from a list of WKB, WKT, EWKT or GeoJSON strings, or Shapely     objects. Geometries will be created by infering the correct deserialization operation.     It is also possible to create a GeoSeries of Points from a Polars     <code>Array</code> with shape     (2 | 3, n).</p> <p>See <code>pl.Series</code> for parameters documentation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gs = st.GeoSeries([\n...     \"POINT(0 0)\",\n...     \"POINT(1 2)\",\n... ])\n&gt;&gt;&gt; gs2 = st.GeoSeries([\n...     [0, 0],\n...     [1, 2],\n... ], dtype=pl.Array(pl.Float64, 2))\n&gt;&gt;&gt; gs.equals(gs2)\nTrue\n&gt;&gt;&gt; gs.dtype\nBinary\n</code></pre> <pre><code>&gt;&gt;&gt; import shapely\n&gt;&gt;&gt; gs = st.GeoSeries([\n...     shapely.Point(0, 0),\n...     shapely.Point(1, 2),\n... ])\n&gt;&gt;&gt; gs2 = st.GeoSeries([\n...     '{\"type\": \"Point\", \"coordinates\": [0, 0]}',\n...     '{\"type\": \"Point\", \"coordinates\": [1, 2]}',\n... ])\n&gt;&gt;&gt; gs.equals(gs2)\nTrue\n</code></pre>"},{"location":"api-reference/geoseries/#polars_st.GeoSeries.st","title":"st  <code>property</code>","text":"<pre><code>st: GeoSeriesNameSpace\n</code></pre>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace","title":"polars_st.GeoSeriesNameSpace","text":""},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.__geo_interface__","title":"polars_st.GeoSeriesNameSpace.__geo_interface__  <code>property</code>","text":"<pre><code>__geo_interface__: dict\n</code></pre> <p>Return a GeoJSON GeometryCollection <code>dict</code> representation of the DataFrame.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.geometry_type","title":"polars_st.GeoSeriesNameSpace.geometry_type","text":"<pre><code>geometry_type() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.geometry_type</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.dimensions","title":"polars_st.GeoSeriesNameSpace.dimensions","text":"<pre><code>dimensions() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.dimensions</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.coordinate_dimension","title":"polars_st.GeoSeriesNameSpace.coordinate_dimension","text":"<pre><code>coordinate_dimension() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.coordinate_dimension</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.area","title":"polars_st.GeoSeriesNameSpace.area","text":"<pre><code>area() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.area</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.bounds","title":"polars_st.GeoSeriesNameSpace.bounds","text":"<pre><code>bounds() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.bounds</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.length","title":"polars_st.GeoSeriesNameSpace.length","text":"<pre><code>length() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.length</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.minimum_clearance","title":"polars_st.GeoSeriesNameSpace.minimum_clearance","text":"<pre><code>minimum_clearance() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.minimum_clearance</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.x","title":"polars_st.GeoSeriesNameSpace.x","text":"<pre><code>x() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.x</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.y","title":"polars_st.GeoSeriesNameSpace.y","text":"<pre><code>y() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.y</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.z","title":"polars_st.GeoSeriesNameSpace.z","text":"<pre><code>z() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.z</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.m","title":"polars_st.GeoSeriesNameSpace.m","text":"<pre><code>m() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.m</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.count_coordinates","title":"polars_st.GeoSeriesNameSpace.count_coordinates","text":"<pre><code>count_coordinates() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.count_coordinates</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.coordinates","title":"polars_st.GeoSeriesNameSpace.coordinates","text":"<pre><code>coordinates(output_dimension: Literal[2, 3] = 2) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.coordinates</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.count_geometries","title":"polars_st.GeoSeriesNameSpace.count_geometries","text":"<pre><code>count_geometries() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.count_geometries</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.get_geometry","title":"polars_st.GeoSeriesNameSpace.get_geometry","text":"<pre><code>get_geometry(index: IntoIntegerExpr) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.get_geometry</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.count_points","title":"polars_st.GeoSeriesNameSpace.count_points","text":"<pre><code>count_points() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.count_points</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.get_point","title":"polars_st.GeoSeriesNameSpace.get_point","text":"<pre><code>get_point(index: IntoIntegerExpr) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.get_point</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.count_interior_rings","title":"polars_st.GeoSeriesNameSpace.count_interior_rings","text":"<pre><code>count_interior_rings() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.count_interior_rings</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.get_interior_ring","title":"polars_st.GeoSeriesNameSpace.get_interior_ring","text":"<pre><code>get_interior_ring(index: IntoIntegerExpr) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.get_interior_ring</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.exterior_ring","title":"polars_st.GeoSeriesNameSpace.exterior_ring","text":"<pre><code>exterior_ring() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.exterior_ring</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.rings","title":"polars_st.GeoSeriesNameSpace.rings","text":"<pre><code>rings() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.rings</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.parts","title":"polars_st.GeoSeriesNameSpace.parts","text":"<pre><code>parts() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.parts</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.precision","title":"polars_st.GeoSeriesNameSpace.precision","text":"<pre><code>precision() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.precision</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.set_precision","title":"polars_st.GeoSeriesNameSpace.set_precision","text":"<pre><code>set_precision(\n    grid_size: IntoDecimalExpr,\n    mode: Literal[\"valid_output\", \"no_topo\", \"keep_collapsed\"] = \"valid_output\",\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.set_precision</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.distance","title":"polars_st.GeoSeriesNameSpace.distance","text":"<pre><code>distance(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.distance</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.hausdorff_distance","title":"polars_st.GeoSeriesNameSpace.hausdorff_distance","text":"<pre><code>hausdorff_distance(\n    other: IntoGeoExprColumn, densify: float | None = None\n) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.hausdorff_distance</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.frechet_distance","title":"polars_st.GeoSeriesNameSpace.frechet_distance","text":"<pre><code>frechet_distance(\n    other: IntoGeoExprColumn, densify: float | None = None\n) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.frechet_distance</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.srid","title":"polars_st.GeoSeriesNameSpace.srid","text":"<pre><code>srid() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.srid</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.set_srid","title":"polars_st.GeoSeriesNameSpace.set_srid","text":"<pre><code>set_srid(srid: IntoIntegerExpr) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.set_srid</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.to_srid","title":"polars_st.GeoSeriesNameSpace.to_srid","text":"<pre><code>to_srid(srid: IntoIntegerExpr) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.to_srid</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.to_wkt","title":"polars_st.GeoSeriesNameSpace.to_wkt","text":"<pre><code>to_wkt(\n    rounding_precision: int | None = 6,\n    trim: bool = True,\n    output_dimension: Literal[2, 3, 4] = 3,\n    old_3d: bool = False,\n) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.to_wkt</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.to_ewkt","title":"polars_st.GeoSeriesNameSpace.to_ewkt","text":"<pre><code>to_ewkt(\n    rounding_precision: int | None = 6,\n    trim: bool = True,\n    output_dimension: Literal[2, 3, 4] = 3,\n    old_3d: bool = False,\n) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.to_ewkt</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.to_wkb","title":"polars_st.GeoSeriesNameSpace.to_wkb","text":"<pre><code>to_wkb(\n    output_dimension: Literal[2, 3, 4] = 3,\n    byte_order: Literal[0, 1] | None = None,\n    include_srid: bool = False,\n) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.to_wkb</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.to_geojson","title":"polars_st.GeoSeriesNameSpace.to_geojson","text":"<pre><code>to_geojson(indent: int | None = None) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.to_geojson</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.to_shapely","title":"polars_st.GeoSeriesNameSpace.to_shapely","text":"<pre><code>to_shapely() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.to_shapely</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.to_dict","title":"polars_st.GeoSeriesNameSpace.to_dict","text":"<pre><code>to_dict() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.to_dict</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.to_geopandas","title":"polars_st.GeoSeriesNameSpace.to_geopandas","text":"<pre><code>to_geopandas(\n    *, use_pyarrow_extension_array: bool = False, **kwargs: Any\n) -&gt; GeoSeries\n</code></pre> <p>Convert this pl.Series to a geopandas GeoSeries.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.has_z","title":"polars_st.GeoSeriesNameSpace.has_z","text":"<pre><code>has_z() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.has_z</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.has_m","title":"polars_st.GeoSeriesNameSpace.has_m","text":"<pre><code>has_m() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.has_m</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.is_ccw","title":"polars_st.GeoSeriesNameSpace.is_ccw","text":"<pre><code>is_ccw() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.is_ccw</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.is_closed","title":"polars_st.GeoSeriesNameSpace.is_closed","text":"<pre><code>is_closed() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.is_closed</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.is_empty","title":"polars_st.GeoSeriesNameSpace.is_empty","text":"<pre><code>is_empty() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.is_empty</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.is_ring","title":"polars_st.GeoSeriesNameSpace.is_ring","text":"<pre><code>is_ring() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.is_ring</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.is_simple","title":"polars_st.GeoSeriesNameSpace.is_simple","text":"<pre><code>is_simple() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.is_simple</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.is_valid","title":"polars_st.GeoSeriesNameSpace.is_valid","text":"<pre><code>is_valid() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.is_valid</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.is_valid_reason","title":"polars_st.GeoSeriesNameSpace.is_valid_reason","text":"<pre><code>is_valid_reason() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.is_valid_reason</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.crosses","title":"polars_st.GeoSeriesNameSpace.crosses","text":"<pre><code>crosses(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.crosses</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.contains","title":"polars_st.GeoSeriesNameSpace.contains","text":"<pre><code>contains(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.contains</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.contains_properly","title":"polars_st.GeoSeriesNameSpace.contains_properly","text":"<pre><code>contains_properly(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.contains_properly</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.covered_by","title":"polars_st.GeoSeriesNameSpace.covered_by","text":"<pre><code>covered_by(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.covered_by</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.covers","title":"polars_st.GeoSeriesNameSpace.covers","text":"<pre><code>covers(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.covers</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.disjoint","title":"polars_st.GeoSeriesNameSpace.disjoint","text":"<pre><code>disjoint(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.disjoint</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.dwithin","title":"polars_st.GeoSeriesNameSpace.dwithin","text":"<pre><code>dwithin(other: IntoGeoExprColumn, distance: float) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.dwithin</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.intersects","title":"polars_st.GeoSeriesNameSpace.intersects","text":"<pre><code>intersects(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.intersects</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.overlaps","title":"polars_st.GeoSeriesNameSpace.overlaps","text":"<pre><code>overlaps(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.overlaps</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.touches","title":"polars_st.GeoSeriesNameSpace.touches","text":"<pre><code>touches(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.touches</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.within","title":"polars_st.GeoSeriesNameSpace.within","text":"<pre><code>within(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.within</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.equals","title":"polars_st.GeoSeriesNameSpace.equals","text":"<pre><code>equals(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.equals</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.equals_exact","title":"polars_st.GeoSeriesNameSpace.equals_exact","text":"<pre><code>equals_exact(other: IntoGeoExprColumn, tolerance: float = 0.0) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.equals_exact</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.equals_identical","title":"polars_st.GeoSeriesNameSpace.equals_identical","text":"<pre><code>equals_identical(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.equals_identical</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.relate","title":"polars_st.GeoSeriesNameSpace.relate","text":"<pre><code>relate(other: IntoGeoExprColumn) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.relate</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.relate_pattern","title":"polars_st.GeoSeriesNameSpace.relate_pattern","text":"<pre><code>relate_pattern(other: IntoGeoExprColumn, pattern: str) -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.relate_pattern</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.union","title":"polars_st.GeoSeriesNameSpace.union","text":"<pre><code>union(other: IntoGeoExprColumn, grid_size: float | None = None) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.union</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.unary_union","title":"polars_st.GeoSeriesNameSpace.unary_union","text":"<pre><code>unary_union(grid_size: float | None = None) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.unary_union</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.coverage_union","title":"polars_st.GeoSeriesNameSpace.coverage_union","text":"<pre><code>coverage_union() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.coverage_union</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.intersection","title":"polars_st.GeoSeriesNameSpace.intersection","text":"<pre><code>intersection(\n    other: IntoGeoExprColumn, grid_size: float | None = None\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.intersection</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.difference","title":"polars_st.GeoSeriesNameSpace.difference","text":"<pre><code>difference(\n    other: IntoGeoExprColumn, grid_size: float | None = None\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.difference</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.symmetric_difference","title":"polars_st.GeoSeriesNameSpace.symmetric_difference","text":"<pre><code>symmetric_difference(\n    other: IntoGeoExprColumn, grid_size: float | None = None\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.symmetric_difference</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.boundary","title":"polars_st.GeoSeriesNameSpace.boundary","text":"<pre><code>boundary() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.boundary</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.buffer","title":"polars_st.GeoSeriesNameSpace.buffer","text":"<pre><code>buffer(\n    distance: IntoDecimalExpr,\n    quad_segs: int = 8,\n    cap_style: Literal[\"round\", \"square\", \"flat\"] = \"round\",\n    join_style: Literal[\"round\", \"mitre\", \"bevel\"] = \"round\",\n    mitre_limit: float = 5.0,\n    single_sided: bool = False,\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.buffer</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.offset_curve","title":"polars_st.GeoSeriesNameSpace.offset_curve","text":"<pre><code>offset_curve(\n    distance: IntoDecimalExpr,\n    quad_segs: int = 8,\n    join_style: Literal[\"round\", \"mitre\", \"bevel\"] = \"round\",\n    mitre_limit: float = 5.0,\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.offset_curve</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.centroid","title":"polars_st.GeoSeriesNameSpace.centroid","text":"<pre><code>centroid() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.centroid</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.center","title":"polars_st.GeoSeriesNameSpace.center","text":"<pre><code>center() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.center</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.clip_by_rect","title":"polars_st.GeoSeriesNameSpace.clip_by_rect","text":"<pre><code>clip_by_rect(xmin: float, ymin: float, xmax: float, ymax: float) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.clip_by_rect</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.convex_hull","title":"polars_st.GeoSeriesNameSpace.convex_hull","text":"<pre><code>convex_hull() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.convex_hull</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.concave_hull","title":"polars_st.GeoSeriesNameSpace.concave_hull","text":"<pre><code>concave_hull(ratio: float = 0.0, allow_holes: bool = False) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.concave_hull</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.segmentize","title":"polars_st.GeoSeriesNameSpace.segmentize","text":"<pre><code>segmentize(max_segment_length: IntoDecimalExpr) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.segmentize</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.envelope","title":"polars_st.GeoSeriesNameSpace.envelope","text":"<pre><code>envelope() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.envelope</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.extract_unique_points","title":"polars_st.GeoSeriesNameSpace.extract_unique_points","text":"<pre><code>extract_unique_points() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.extract_unique_points</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.build_area","title":"polars_st.GeoSeriesNameSpace.build_area","text":"<pre><code>build_area() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.build_area</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.make_valid","title":"polars_st.GeoSeriesNameSpace.make_valid","text":"<pre><code>make_valid() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.make_valid</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.normalize","title":"polars_st.GeoSeriesNameSpace.normalize","text":"<pre><code>normalize() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.normalize</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.node","title":"polars_st.GeoSeriesNameSpace.node","text":"<pre><code>node() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.node</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.point_on_surface","title":"polars_st.GeoSeriesNameSpace.point_on_surface","text":"<pre><code>point_on_surface() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.point_on_surface</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.remove_repeated_points","title":"polars_st.GeoSeriesNameSpace.remove_repeated_points","text":"<pre><code>remove_repeated_points(tolerance: IntoDecimalExpr = 0.0) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.remove_repeated_points</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.reverse","title":"polars_st.GeoSeriesNameSpace.reverse","text":"<pre><code>reverse() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.reverse</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.simplify","title":"polars_st.GeoSeriesNameSpace.simplify","text":"<pre><code>simplify(\n    tolerance: IntoDecimalExpr, preserve_topology: bool = True\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.simplify</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.minimum_rotated_rectangle","title":"polars_st.GeoSeriesNameSpace.minimum_rotated_rectangle","text":"<pre><code>minimum_rotated_rectangle() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.minimum_rotated_rectangle</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.snap","title":"polars_st.GeoSeriesNameSpace.snap","text":"<pre><code>snap(other: IntoGeoExprColumn, tolerance: IntoDecimalExpr) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.snap</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.shortest_line","title":"polars_st.GeoSeriesNameSpace.shortest_line","text":"<pre><code>shortest_line(other: IntoGeoExprColumn) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.shortest_line</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.affine_transform","title":"polars_st.GeoSeriesNameSpace.affine_transform","text":"<pre><code>affine_transform(matrix: IntoExprColumn | Sequence[float]) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.affine_transform</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.translate","title":"polars_st.GeoSeriesNameSpace.translate","text":"<pre><code>translate(\n    x: IntoDecimalExpr = 0.0, y: IntoDecimalExpr = 0.0, z: IntoDecimalExpr = 0.0\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.translate</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.rotate","title":"polars_st.GeoSeriesNameSpace.rotate","text":"<pre><code>rotate(\n    angle: IntoDecimalExpr,\n    origin: (\n        Literal[\"center\", \"centroid\"] | Sequence[float] | Expr | Series\n    ) = \"center\",\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.rotate</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.scale","title":"polars_st.GeoSeriesNameSpace.scale","text":"<pre><code>scale(\n    x: IntoDecimalExpr = 1.0,\n    y: IntoDecimalExpr = 1.0,\n    z: IntoDecimalExpr = 1.0,\n    origin: (\n        Literal[\"center\", \"centroid\"] | Sequence[float] | Expr | Series\n    ) = \"center\",\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.scale</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.interpolate","title":"polars_st.GeoSeriesNameSpace.interpolate","text":"<pre><code>interpolate(distance: IntoDecimalExpr, normalized: bool = False) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.interpolate</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.line_merge","title":"polars_st.GeoSeriesNameSpace.line_merge","text":"<pre><code>line_merge(directed: bool = False) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.line_merge</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.shared_paths","title":"polars_st.GeoSeriesNameSpace.shared_paths","text":"<pre><code>shared_paths(other: IntoGeoExprColumn) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.shared_paths</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.total_bounds","title":"polars_st.GeoSeriesNameSpace.total_bounds","text":"<pre><code>total_bounds() -&gt; Series\n</code></pre> <p>See <code>GeoExprNameSpace.total_bounds</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.multipoint","title":"polars_st.GeoSeriesNameSpace.multipoint","text":"<pre><code>multipoint() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.multipoint</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.multilinestring","title":"polars_st.GeoSeriesNameSpace.multilinestring","text":"<pre><code>multilinestring() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.multilinestring</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.multipolygon","title":"polars_st.GeoSeriesNameSpace.multipolygon","text":"<pre><code>multipolygon() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.multipolygon</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.geometrycollection","title":"polars_st.GeoSeriesNameSpace.geometrycollection","text":"<pre><code>geometrycollection() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.geometrycollection</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.collect","title":"polars_st.GeoSeriesNameSpace.collect","text":"<pre><code>collect() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.collect</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.union_all","title":"polars_st.GeoSeriesNameSpace.union_all","text":"<pre><code>union_all(grid_size: float | None = None) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.union_all</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.coverage_union_all","title":"polars_st.GeoSeriesNameSpace.coverage_union_all","text":"<pre><code>coverage_union_all() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.coverage_union_all</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.intersection_all","title":"polars_st.GeoSeriesNameSpace.intersection_all","text":"<pre><code>intersection_all(grid_size: float | None = None) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.intersection_all</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.difference_all","title":"polars_st.GeoSeriesNameSpace.difference_all","text":"<pre><code>difference_all(grid_size: float | None = None) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.difference_all</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.symmetric_difference_all","title":"polars_st.GeoSeriesNameSpace.symmetric_difference_all","text":"<pre><code>symmetric_difference_all(grid_size: float | None = None) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.symmetric_difference_all</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.polygonize","title":"polars_st.GeoSeriesNameSpace.polygonize","text":"<pre><code>polygonize() -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.polygonize</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.voronoi_polygons","title":"polars_st.GeoSeriesNameSpace.voronoi_polygons","text":"<pre><code>voronoi_polygons(\n    tolerance: float = 0.0,\n    extend_to: bytes | None = None,\n    only_edges: bool = False,\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.voronoi_polygons</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.delaunay_triangles","title":"polars_st.GeoSeriesNameSpace.delaunay_triangles","text":"<pre><code>delaunay_triangles(\n    tolerance: float = 0.0, only_edges: bool = False\n) -&gt; GeoSeries\n</code></pre> <p>See <code>GeoExprNameSpace.delaunay_triangles</code>.</p>"},{"location":"api-reference/geoseries/#polars_st.GeoSeriesNameSpace.plot","title":"polars_st.GeoSeriesNameSpace.plot","text":"<pre><code>plot(**kwargs: Unpack[EncodeKwds]) -&gt; Chart\n</code></pre> <p>Draw map plot.</p> <p>Polars does not implement plotting logic itself but instead defers to <code>Altair</code>.</p> <p><code>df.st.plot(**kwargs)</code> is shorthand for <code>alt.Chart(df).mark_geoshape().encode(**kwargs).interactive()</code>. Please read Altair GeoShape documentation for available options.</p>"},{"location":"api-reference/input/","title":"File input","text":""},{"location":"api-reference/input/#polars_st.read_file","title":"polars_st.read_file","text":"<pre><code>read_file(\n    path_or_buffer: Path | str | bytes,\n    /,\n    layer: int | str | None = None,\n    encoding: str | None = None,\n    columns: Sequence[str] | None = None,\n    read_geometry: bool = True,\n    force_2d: bool = False,\n    skip_features: int = 0,\n    max_features: int | None = None,\n    where: str | None = None,\n    bbox: tuple[float, float, float, float] | None = None,\n    fids: Sequence[int] | None = None,\n    sql: str | None = None,\n    sql_dialect: str | None = None,\n    return_fids: bool = False,\n) -&gt; GeoDataFrame\n</code></pre> <p>Read OGR data source into a GeoDataFrame.</p> <p>IMPORTANT: non-linear geometry types (e.g., MultiSurface) are converted to their linear approximations.</p> <p>Parameters:</p> <ul> <li> <code>path_or_buffer</code>               (<code>Path | str | bytes</code>)           \u2013            <p>A dataset path or URI, or raw buffer.</p> </li> <li> <code>layer</code>               (<code>int | str | None</code>, default:                   <code>None</code> )           \u2013            <p>If an integer is provided, it corresponds to the index of the layer with the data source.  If a string is provided, it must match the name of the layer in the data source.  Defaults to first layer in data source.</p> </li> <li> <code>encoding</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If present, will be used as the encoding for reading string values from the data source, unless encoding can be inferred directly from the data source.</p> </li> <li> <code>columns</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of column names to import from the data source.  Column names must exactly match the names in the data source, and will be returned in the order they occur in the data source.  To avoid reading any columns, pass an empty list-like.</p> </li> <li> <code>read_geometry</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, will read geometry into WKB. If False, geometry will be None. Defaults to <code>True</code>.</p> </li> <li> <code>force_2d</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If the geometry has Z values, setting this to True will cause those to be ignored and 2D geometries to be returned. Defaults to <code>False</code>.</p> </li> <li> <code>skip_features</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Number of features to skip from the beginning of the file before returning features.  Must be less than the total number of features in the file.</p> </li> <li> <code>max_features</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of features to read from the file.  Must be less than the total number of features in the file minus skip_features (if used).</p> </li> <li> <code>where</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Where clause to filter features in layer by attribute values.  Uses a restricted form of SQL WHERE clause, defined here. For examples:</p> <ul> <li><code>\"ISO_A3 = 'CAN'\"</code></li> <li><code>\"POP_EST &gt; 10000000 AND POP_EST &lt; 100000000\"</code></li> </ul> </li> <li> <code>bbox</code>               (<code>tuple[float, float, float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>If present, will be used to filter records whose geometry intersects this box.  This must be in the same CRS as the dataset.  If GEOS is present and used by GDAL, only geometries that intersect this bbox will be returned; if GEOS is not available or not used by GDAL, all geometries with bounding boxes that intersect this bbox will be returned.</p> </li> <li> <code>fids</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Array of integer feature id (FID) values to select. Cannot be combined with other keywords to select a subset (<code>skip_features</code>, <code>max_features</code>, <code>where</code> or <code>bbox</code>). Note that the starting index is driver and file specific (e.g. typically 0 for Shapefile and 1 for GeoPackage, but can still depend on the specific file). The performance of reading a large number of features usings FIDs is also driver specific.</p> </li> <li> <code>sql</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The SQL statement to execute. Look at the sql_dialect parameter for more information on the syntax to use for the query. When combined with other keywords like <code>columns</code>, <code>skip_features</code>, <code>max_features</code>, <code>where</code>, <code>bbox</code>, or <code>mask</code>, those are applied after the SQL query. Be aware that this can have an impact on performance, (e.g. filtering with the <code>bbox</code> or <code>mask</code> keywords may not use spatial indexes). Cannot be combined with the <code>layer</code> or <code>fids</code> keywords.</p> </li> <li> <code>sql_dialect</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The SQL dialect the SQL statement is written in. Possible values:</p> <ul> <li><code>None</code>: if the data source natively supports SQL, its specific SQL dialect     will be used by default (eg. SQLite and Geopackage: <code>SQLITE</code>, PostgreSQL).     If the data source doesn't natively support SQL, the <code>OGRSQL</code> dialect is     the default.</li> <li><code>OGRSQL</code>: can be used on any data source. Performance can suffer     when used on data sources with native support for SQL.</li> <li><code>SQLITE</code>: can be used on any data source. All spatialite_     functions can be used. Performance can suffer on data sources with     native support for SQL, except for Geopackage and SQLite as this is     their native SQL dialect.</li> </ul> </li> <li> <code>return_fids</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, will return the FIDs of the feature that were read.</p> </li> </ul>"},{"location":"api-reference/parsing/","title":"Geometry Parsing","text":""},{"location":"api-reference/parsing/#polars_st.from_wkb","title":"polars_st.from_wkb","text":"<pre><code>from_wkb(expr: IntoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Parse geometries from Well-Known Binary (WKB) representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gdf = pl.read_database(\n...     query=\"SELECT ST_AsEWKB(geom) AS geometry FROM test_data\",\n...     connection=user_conn,\n... )\n&gt;&gt;&gt; gdf = df.select(st.from_wkb(\"geometry\"))\n</code></pre>"},{"location":"api-reference/parsing/#polars_st.from_wkt","title":"polars_st.from_wkt","text":"<pre><code>from_wkt(expr: IntoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Parse geometries from Well-Known Text (WKT) representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.Series(\"geometry\", [\n...     \"POINT(0 0)\",\n...     \"POINT(1 2)\",\n... ]).to_frame()\n&gt;&gt;&gt; gdf = df.select(st.from_wkt(\"geometry\"))\n</code></pre>"},{"location":"api-reference/parsing/#polars_st.from_ewkt","title":"polars_st.from_ewkt","text":"<pre><code>from_ewkt(expr: IntoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Parse geometries from Extended Well-Known Text (EWKT) representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.Series(\"geometry\", [\n...     \"SRID=4326;POINT(0 0)\",\n...     \"SRID=3857;POINT(1 2)\",\n... ]).to_frame()\n&gt;&gt;&gt; gdf = df.select(st.from_ewkt(\"geometry\"))\n</code></pre>"},{"location":"api-reference/parsing/#polars_st.from_geojson","title":"polars_st.from_geojson","text":"<pre><code>from_geojson(expr: IntoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Parse geometries from GeoJSON representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.Series(\"geometry\", [\n...     '{\"type\": \"Point\", \"coordinates\": [0, 0]}',\n...     '{\"type\": \"Point\", \"coordinates\": [1, 2]}',\n... ]).to_frame()\n&gt;&gt;&gt; gdf = df.select(st.from_geojson(\"geometry\"))\n</code></pre>"},{"location":"api-reference/parsing/#polars_st.from_xy","title":"polars_st.from_xy","text":"<pre><code>from_xy(\n    x: IntoDecimalExpr, y: IntoDecimalExpr, z: IntoDecimalExpr | None = None\n) -&gt; GeoExpr\n</code></pre> <p>Create points from x, y (, z) coordinates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\n...     \"x\": [0, 1],\n...     \"y\": [0, 2],\n... })\n&gt;&gt;&gt; gdf = df.select(st.from_xy(\"x\", \"y\"))\n</code></pre>"},{"location":"api-reference/parsing/#polars_st.from_shapely","title":"polars_st.from_shapely","text":"<pre><code>from_shapely(expr: IntoExprColumn) -&gt; GeoExpr\n</code></pre> <p>Parse geometries from shapely objects.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import shapely\n&gt;&gt;&gt; df = pl.Series(\"geometry\", [\n...     shapely.Point(0, 0),\n...     shapely.Point(1, 2),\n... ], dtype=pl.Object).to_frame()\n&gt;&gt;&gt; gdf = df.select(st.from_shapely(\"geometry\"))\n</code></pre>"},{"location":"api-reference/parsing/#polars_st.from_geopandas","title":"polars_st.from_geopandas","text":"<pre><code>from_geopandas(\n    data: GeoDataFrame | GeoSeries,\n    *,\n    schema_overrides: SchemaDict | None = None,\n    rechunk: bool = True,\n    nan_to_null: bool = True,\n    include_index: bool = False\n) -&gt; GeoDataFrame | GeoSeries\n</code></pre> <p>Create DataFrame or Series from Geopandas GeoDataFrame or GeoSeries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import shapely\n&gt;&gt;&gt; import geopandas as gpd\n&gt;&gt;&gt; pd_gdf = gpd.GeoDataFrame({\n...     \"geometry\": [shapely.Point(0, 0), shapely.Point(1, 2)]\n... }, crs=\"EPSG:4326\")\n&gt;&gt;&gt; gdf = st.from_geopandas(pd_gdf)\n</code></pre>"},{"location":"api-reference/sugar/","title":"Expression Shorthand","text":"<p>When a function only involves one geometry column, such as <code>area</code> or <code>buffer</code>, it is possible to call that function directly from the <code>polars_st</code> module, allowing us to write: <code>gdf.select(st.area())</code> instead of <code>gdf.select(st.geom().st.area())</code>.</p> <p>The following functions can be used that way:</p>"},{"location":"api-reference/sugar/#polars_st.geometry_type","title":"polars_st.geometry_type","text":"<pre><code>geometry_type(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.geometry_type()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.dimensions","title":"polars_st.dimensions","text":"<pre><code>dimensions(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.dimensions()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.coordinate_dimension","title":"polars_st.coordinate_dimension","text":"<pre><code>coordinate_dimension(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.coordinate_dimension()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.area","title":"polars_st.area","text":"<pre><code>area(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.area()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.bounds","title":"polars_st.bounds","text":"<pre><code>bounds(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.bounds()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.length","title":"polars_st.length","text":"<pre><code>length(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.length()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.minimum_clearance","title":"polars_st.minimum_clearance","text":"<pre><code>minimum_clearance(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.minimum_clearance()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.x","title":"polars_st.x","text":"<pre><code>x(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.x()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.y","title":"polars_st.y","text":"<pre><code>y(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.y()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.z","title":"polars_st.z","text":"<pre><code>z(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.z()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.m","title":"polars_st.m","text":"<pre><code>m(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.m()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.count_coordinates","title":"polars_st.count_coordinates","text":"<pre><code>count_coordinates(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.count_coordinates()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.coordinates","title":"polars_st.coordinates","text":"<pre><code>coordinates(*columns: str, output_dimension: Literal[2, 3] = 2) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.coordinates(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.count_geometries","title":"polars_st.count_geometries","text":"<pre><code>count_geometries(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.count_geometries()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.get_geometry","title":"polars_st.get_geometry","text":"<pre><code>get_geometry(*columns: str, index: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.get_geometry(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.count_points","title":"polars_st.count_points","text":"<pre><code>count_points(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.count_points()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.get_point","title":"polars_st.get_point","text":"<pre><code>get_point(*columns: str, index: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.get_point(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.count_interior_rings","title":"polars_st.count_interior_rings","text":"<pre><code>count_interior_rings(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.count_interior_rings()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.get_interior_ring","title":"polars_st.get_interior_ring","text":"<pre><code>get_interior_ring(*columns: str, index: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.get_interior_ring(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.exterior_ring","title":"polars_st.exterior_ring","text":"<pre><code>exterior_ring(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.exterior_ring()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.rings","title":"polars_st.rings","text":"<pre><code>rings(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.rings()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.parts","title":"polars_st.parts","text":"<pre><code>parts(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.parts()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.precision","title":"polars_st.precision","text":"<pre><code>precision(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.precision()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.set_precision","title":"polars_st.set_precision","text":"<pre><code>set_precision(\n    *columns: str,\n    grid_size: IntoDecimalExpr,\n    mode: Literal[\"valid_output\", \"no_topo\", \"keep_collapsed\"] = \"valid_output\"\n) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.set_precision(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.srid","title":"polars_st.srid","text":"<pre><code>srid(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.srid()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.set_srid","title":"polars_st.set_srid","text":"<pre><code>set_srid(*columns: str, srid: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.set_srid(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.to_srid","title":"polars_st.to_srid","text":"<pre><code>to_srid(*columns: str, srid: IntoIntegerExpr) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.to_srid(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.to_wkt","title":"polars_st.to_wkt","text":"<pre><code>to_wkt(\n    *columns: str,\n    rounding_precision: int | None = 6,\n    trim: bool = True,\n    output_dimension: Literal[2, 3, 4] = 3,\n    old_3d: bool = False\n) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.to_wkt(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.to_ewkt","title":"polars_st.to_ewkt","text":"<pre><code>to_ewkt(\n    *columns: str,\n    rounding_precision: int | None = 6,\n    trim: bool = True,\n    output_dimension: Literal[2, 3, 4] = 3,\n    old_3d: bool = False\n) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.to_ewkt(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.to_wkb","title":"polars_st.to_wkb","text":"<pre><code>to_wkb(\n    *columns: str,\n    output_dimension: Literal[2, 3, 4] = 3,\n    byte_order: Literal[0, 1] | None = None,\n    include_srid: bool = False\n) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.to_wkb(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.to_geojson","title":"polars_st.to_geojson","text":"<pre><code>to_geojson(*columns: str, indent: int | None = None) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.to_geojson(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.to_shapely","title":"polars_st.to_shapely","text":"<pre><code>to_shapely(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.to_shapely()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.to_dict","title":"polars_st.to_dict","text":"<pre><code>to_dict(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.to_dict()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.has_z","title":"polars_st.has_z","text":"<pre><code>has_z(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.has_z()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.has_m","title":"polars_st.has_m","text":"<pre><code>has_m(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.has_m()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.is_ccw","title":"polars_st.is_ccw","text":"<pre><code>is_ccw(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.is_ccw()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.is_closed","title":"polars_st.is_closed","text":"<pre><code>is_closed(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.is_closed()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.is_empty","title":"polars_st.is_empty","text":"<pre><code>is_empty(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.is_empty()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.is_ring","title":"polars_st.is_ring","text":"<pre><code>is_ring(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.is_ring()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.is_simple","title":"polars_st.is_simple","text":"<pre><code>is_simple(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.is_simple()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.is_valid","title":"polars_st.is_valid","text":"<pre><code>is_valid(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.is_valid()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.is_valid_reason","title":"polars_st.is_valid_reason","text":"<pre><code>is_valid_reason(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.is_valid_reason()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.unary_union","title":"polars_st.unary_union","text":"<pre><code>unary_union(*columns: str, grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.unary_union(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.coverage_union","title":"polars_st.coverage_union","text":"<pre><code>coverage_union(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.coverage_union()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.boundary","title":"polars_st.boundary","text":"<pre><code>boundary(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.boundary()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.buffer","title":"polars_st.buffer","text":"<pre><code>buffer(\n    *columns: str,\n    distance: IntoDecimalExpr,\n    quad_segs: int = 8,\n    cap_style: Literal[\"round\", \"square\", \"flat\"] = \"round\",\n    join_style: Literal[\"round\", \"mitre\", \"bevel\"] = \"round\",\n    mitre_limit: float = 5.0,\n    single_sided: bool = False\n) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.buffer(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.offset_curve","title":"polars_st.offset_curve","text":"<pre><code>offset_curve(\n    *columns: str,\n    distance: IntoDecimalExpr,\n    quad_segs: int = 8,\n    join_style: Literal[\"round\", \"mitre\", \"bevel\"] = \"round\",\n    mitre_limit: float = 5.0\n) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.offset_curve(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.centroid","title":"polars_st.centroid","text":"<pre><code>centroid(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.centroid()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.center","title":"polars_st.center","text":"<pre><code>center(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.center()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.clip_by_rect","title":"polars_st.clip_by_rect","text":"<pre><code>clip_by_rect(\n    *columns: str, xmin: float, ymin: float, xmax: float, ymax: float\n) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.clip_by_rect()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.convex_hull","title":"polars_st.convex_hull","text":"<pre><code>convex_hull(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.convex_hull()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.concave_hull","title":"polars_st.concave_hull","text":"<pre><code>concave_hull(\n    *columns: str, ratio: float = 0.0, allow_holes: bool = False\n) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.concave_hull(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.segmentize","title":"polars_st.segmentize","text":"<pre><code>segmentize(*columns: str, max_segment_length: IntoDecimalExpr) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.segmentize(max_segment_length)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.envelope","title":"polars_st.envelope","text":"<pre><code>envelope(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.envelope()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.extract_unique_points","title":"polars_st.extract_unique_points","text":"<pre><code>extract_unique_points(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.extract_unique_points()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.build_area","title":"polars_st.build_area","text":"<pre><code>build_area(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.build_area()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.make_valid","title":"polars_st.make_valid","text":"<pre><code>make_valid(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.make_valid()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.normalize","title":"polars_st.normalize","text":"<pre><code>normalize(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.normalize()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.node","title":"polars_st.node","text":"<pre><code>node(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.node()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.point_on_surface","title":"polars_st.point_on_surface","text":"<pre><code>point_on_surface(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.point_on_surface()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.remove_repeated_points","title":"polars_st.remove_repeated_points","text":"<pre><code>remove_repeated_points(\n    *columns: str, tolerance: IntoDecimalExpr = 0.0\n) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.remove_repeated_points(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.reverse","title":"polars_st.reverse","text":"<pre><code>reverse(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.reverse()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.simplify","title":"polars_st.simplify","text":"<pre><code>simplify(\n    *columns: str, tolerance: IntoDecimalExpr, preserve_topology: bool = True\n) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.simplify(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.minimum_rotated_rectangle","title":"polars_st.minimum_rotated_rectangle","text":"<pre><code>minimum_rotated_rectangle(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.minimum_rotated_rectangle()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.affine_transform","title":"polars_st.affine_transform","text":"<pre><code>affine_transform(\n    *columns: str, matrix: IntoExprColumn | Sequence[float]\n) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.affine_transform(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.translate","title":"polars_st.translate","text":"<pre><code>translate(\n    *columns: str,\n    x: IntoDecimalExpr = 0.0,\n    y: IntoDecimalExpr = 0.0,\n    z: IntoDecimalExpr = 0.0\n) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.translate(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.rotate","title":"polars_st.rotate","text":"<pre><code>rotate(\n    *columns: str,\n    angle: IntoDecimalExpr,\n    origin: (\n        Literal[\"center\", \"centroid\"] | Sequence[float] | Expr | Series\n    ) = \"center\"\n) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.rotate(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.scale","title":"polars_st.scale","text":"<pre><code>scale(\n    *columns: str,\n    x: IntoDecimalExpr = 1.0,\n    y: IntoDecimalExpr = 1.0,\n    z: IntoDecimalExpr = 1.0,\n    origin: (\n        Literal[\"center\", \"centroid\"] | Sequence[float] | Expr | Series\n    ) = \"center\"\n) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.scale(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.interpolate","title":"polars_st.interpolate","text":"<pre><code>interpolate(\n    *columns: str, distance: IntoDecimalExpr, normalized: bool = False\n) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.interpolate()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.line_merge","title":"polars_st.line_merge","text":"<pre><code>line_merge(*columns: str, directed: bool = False) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.line_merge()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.total_bounds","title":"polars_st.total_bounds","text":"<pre><code>total_bounds(*columns: str) -&gt; Expr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.total_bounds()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.multipoint","title":"polars_st.multipoint","text":"<pre><code>multipoint(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.multipoint()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.multilinestring","title":"polars_st.multilinestring","text":"<pre><code>multilinestring(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.multilinestring()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.multipolygon","title":"polars_st.multipolygon","text":"<pre><code>multipolygon(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.multipolygon()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.geometrycollection","title":"polars_st.geometrycollection","text":"<pre><code>geometrycollection(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.geometrycollection()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.collect","title":"polars_st.collect","text":"<pre><code>collect(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.geometrycollection()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.union_all","title":"polars_st.union_all","text":"<pre><code>union_all(*columns: str, grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.union_all(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.coverage_union_all","title":"polars_st.coverage_union_all","text":"<pre><code>coverage_union_all(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.coverage_union_all()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.intersection_all","title":"polars_st.intersection_all","text":"<pre><code>intersection_all(*columns: str, grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.intersection_all()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.difference_all","title":"polars_st.difference_all","text":"<pre><code>difference_all(*columns: str, grid_size: float | None = None) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.difference_all(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.symmetric_difference_all","title":"polars_st.symmetric_difference_all","text":"<pre><code>symmetric_difference_all(\n    *columns: str, grid_size: float | None = None\n) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.symmetric_difference_all(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.polygonize","title":"polars_st.polygonize","text":"<pre><code>polygonize(*columns: str) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.polygonize()</code>.</p>"},{"location":"api-reference/sugar/#polars_st.voronoi_polygons","title":"polars_st.voronoi_polygons","text":"<pre><code>voronoi_polygons(\n    *columns: str,\n    tolerance: float = 0.0,\n    extend_to: bytes | None = None,\n    only_edges: bool = False\n) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.voronoi_polygons(...)</code>.</p>"},{"location":"api-reference/sugar/#polars_st.delaunay_triangles","title":"polars_st.delaunay_triangles","text":"<pre><code>delaunay_triangles(\n    *columns: str, tolerance: float = 0.0, only_edges: bool = False\n) -&gt; GeoExpr\n</code></pre> <p>This function is syntactic sugar for <code>st.geom(columns).st.delaunay_triangles(...)</code>.</p>"}]}